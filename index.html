<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Brain Lab — Teasers & Training</title>
    <style>
        :root {
            --bg: #0b0d12;
            --card: #12151c;
            --fg: #e9edf5;
            --muted: #a5adbb;
            --acc: #7cc9ff;
            --ok: #6ee7a3;
            --bad: #ff7a7a;
            --warn: #ffd36b;
            --border: #1f2430;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
            background: radial-gradient(1200px 800px at 20% -10%, #142034 0%, #0b0d12 55%) fixed;
            color: var(--fg)
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            padding: 24px
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px
        }

        h1 {
            font-size: 22px;
            margin: 0
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .tab {
            border: 1px solid var(--border);
            background: linear-gradient(180deg, #181c25, #12151c);
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            user-select: none
        }

        .tab[aria-selected="true"] {
            outline: 2px solid var(--acc);
        }

        .card {
            background: linear-gradient(180deg, #151925, #10131b);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, .4);
            border-radius: 16px;
            padding: 18px;
            margin-top: 14px
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center
        }

        button,
        .btn {
            background: #1a2030;
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 10px 14px;
            border-radius: 12px;
            cursor: pointer
        }

        button:hover {
            filter: brightness(1.08)
        }

        .btn-ghost {
            background: transparent;
            border-color: transparent;
            color: var(--muted)
        }

        .muted {
            color: var(--muted)
        }

        .big {
            font-size: 24px
        }

        .center {
            text-align: center
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .two {
            grid-template-columns: repeat(2, minmax(0, 1fr))
        }

        .three {
            grid-template-columns: repeat(3, minmax(0, 1fr))
        }

        .four {
            grid-template-columns: repeat(4, minmax(0, 1fr))
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0f1219;
            color: var(--fg)
        }

        .ok {
            color: var(--ok)
        }

        .bad {
            color: var(--bad)
        }

        .timer {
            font-variant-numeric: tabular-nums
        }

        .pill {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #10131b;
            color: var(--muted);
            font-size: 12px
        }

        .hidden {
            display: none !important
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            background: #0c0f15;
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 6px
        }

        .finish {
            padding: 10px;
            border: 1px dashed var(--border);
            background: #0e1220;
            border-radius: 12px
        }

        .flash {
            animation: flash .25s ease-out
        }

        @keyframes flash {
            from {
                transform: scale(1.04);
                text-shadow: 0 0 12px rgba(255, 255, 255, .08)
            }

            to {
                transform: scale(1);
                text-shadow: none
            }
        }

        @media (max-width:680px) {

            .two,
            .three,
            .four {
                grid-template-columns: 1fr
            }
        }

        /* Tango helpers */
        .board {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            gap: 6px;
            justify-content: center
        }

        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: #0f1219;
            cursor: pointer;
            position: relative
        }

        .cell[data-lock="1"] {
            background: #141a25
        }

        .eq-right::after {
            content: '=';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: var(--muted)
        }

        .eq-down::before {
            content: '=';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--muted)
        }

        /* Futoshiki (4×4) */
        .futo-board { display:grid; grid-template-columns:repeat(4,40px); gap:6px; justify-content:center }
        .futo-cell { width:40px; height:40px; display:flex; align-items:center; justify-content:center;
        border:1px solid var(--border); border-radius:10px; background:#0f1219; cursor:pointer; position:relative; font-weight:600 }
        .futo-cell[data-lock="1"] { background:#141a25; cursor:default }
        .lt-right::after { content:'‹'; position:absolute; right:-10px; top:50%; transform:translateY(-50%); font-size:12px; color:var(--muted) }
        .gt-right::after { content:'›'; position:absolute; right:-10px; top:50%; transform:translateY(-50%); font-size:12px; color:var(--muted) }
        .lt-down::before  { content:'∧'; position:absolute; bottom:-12px; left:50%; transform:translateX(-50%); font-size:12px; color:var(--muted) }
        .gt-down::before  { content:'∨'; position:absolute; bottom:-12px; left:50%; transform:translateX(-50%); font-size:12px; color:var(--muted) }

    </style>
    <script src="rc_topics.js"></script>
</head>

<body>
    <div class="wrap">
        <header>
            <h1>🧠 Brain Lab</h1>
            <div class="tabs" role="tablist" aria-label="Modes">
                <div class="tab" role="tab" aria-selected="true" data-panel="teasers">Teasers</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="math">Speed Math</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="stroop">Stroop</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="gng">Go/No-Go</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="estroop">Emotional Stroop</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="futo">Futoshiki 4×4</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="nback">N-Back</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="nmem">Number Memory</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="read">Reading</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="tango">Tango 6×6</div>
            </div>
        </header>

        <!-- TEASERS -->
        <section id="teasers" class="card" role="tabpanel">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Solved <span id="teaserSolved">0</span>/<span
                            id="teaserTotal">0</span></div>
                    <h2 style="margin:6px 0 0">Brain Teaser</h2>
                </div>
                <div class="row">
                    <button id="newTeaser">New</button>
                    <button id="markSolved">Mark solved</button>
                    <button id="reveal">Reveal</button>
                </div>
            </div>
            <div style="height:8px"></div>
            <div id="teaserQ" class="big"></div>
            <details id="answerBox" class="card" style="margin-top:14px">
                <summary class="muted">Answer / Hint</summary>
                <div id="teaserA" style="margin-top:8px"></div>
            </details>
        </section>

        <!-- SPEED MATH -->
        <section id="math" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">30s arithmetic drill • High score <span id="mathBest">0</span></div>
                    <h2 style="margin:6px 0 0">Speed Math</h2>
                </div>
                <div class="row"><button id="mathStart">Start</button>
                    <div class="pill timer" id="mathTime">30</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div class="big" id="mathQ">Press Start</div>
                <div class="row center" style="justify-content:center;margin-top:10px">
                    <input id="mathInput" type="number" inputmode="numeric" placeholder="Answer"
                        style="max-width:220px" />
                    <button id="mathCheck">OK</button>
                </div>
                <div class="muted" style="margin-top:6px">Score: <span id="mathScore">0</span> • Streak <span
                        id="mathStreak">0</span> • <span id="mathFeedback"></span></div>
                <div id="mathFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- STROOP -->
        <section id="stroop" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Name the INK color • High score <span id="stroopBest">0</span></div>
                    <h2 style="margin:6px 0 0">Stroop Test</h2>
                </div>
                <div class="row"><button id="stroopStart">Start</button>
                    <div class="pill timer" id="stroopTime">30</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="stroopWord" class="big" style="font-weight:700;letter-spacing:.5px;">Press Start</div>
                <div id="stroopBtns" class="grid two" style="max-width:520px;margin:12px auto 0"></div>
                <div class="muted" style="margin-top:6px">Score: <span id="stroopScore">0</span> • Accuracy <span
                        id="stroopAcc">0%</span></div>
                <div id="stroopFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- GO/NO-GO -->
        <section id="gng" class="card hidden" role="tabpanel" aria-hidden="true">
        <div class="row" style="justify-content:space-between">
            <div>
            <div class="pill">Tap on GO, withhold on NO-GO • Best <span id="gngBest">0%</span></div>
            <h2 style="margin:6px 0 0">Go/No-Go</h2>
            </div>
            <div class="row">
            <label class="pill">No-Go % <span id="gngProbLbl">20</span></label>
            <input id="gngProb" type="range" min="10" max="40" step="5" value="20" style="width:140px" />
            <button id="gngStart">Start</button>
            </div>
        </div>
        <div class="center" style="margin-top:10px">
            <div id="gngStim" class="big" style="height:60px">Press Start</div>
            <div class="row center" style="justify-content:center;margin-top:8px">
            <button id="gngGoBtn">GO (<span class="kbd">G</span>)</button>
            </div>
            <div class="muted" style="margin-top:6px">
            Trials: <span id="gngCount">0</span> • Hits <span id="gngHits">0</span> • False alarms <span id="gngFA">0</span> • Acc <span id="gngAcc">0%</span>
            </div>
            <div id="gngFinish" class="finish hidden" style="margin-top:10px"></div>
        </div>
        </section>

        <!-- EMOTIONAL STROOP -->
        <section id="estroop" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                <div class="pill">Name the INK color (emotion words) • Best <span id="esBest">0</span></div>
                <h2 style="margin:6px 0 0">Emotional Stroop</h2>
                </div>
                <div class="row"><button id="esStart">Start</button>
                <div class="pill timer" id="esTime">30</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="esWord" class="big" style="font-weight:700;letter-spacing:.5px;">Press Start</div>
                <div id="esBtns" class="grid two" style="max-width:520px;margin:12px auto 0"></div>
                <div class="muted" style="margin-top:6px">Score: <span id="esScore">0</span> • Acc <span id="esAcc">0%</span></div>
                <div id="esFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
            </section>



        <!-- N-BACK -->
        <section id="nback" class="card hidden" role="tabpanel" aria-hidden="true">
        <div class="row" style="justify-content:space-between">
            <div>
            <div class="pill">Press the feature that repeats N steps back • Best hits <span id="nbBest">0</span></div>
            <h2 style="margin:6px 0 0">N-Back (Multi-Feature)</h2>
            </div>
            <div class="row">
            <label class="pill">N
                <select id="nbN">
                <option>1</option><option>2</option><option>3</option>
                </select>
            </label>
            <label class="pill"><input type="checkbox" id="nbFeatSymbol" checked /> Symbol</label>
            <label class="pill"><input type="checkbox" id="nbFeatColor" checked /> Color</label>
            <label class="pill"><input type="checkbox" id="nbFeatSize" /> Size</label>
            <label class="pill"><input type="checkbox" id="nbFeatPos" /> Position</label>
            <label class="pill">Set
                <select id="nbSet"><option>Letters</option><option>Digits</option></select>
            </label>
            <button id="nbStart">Start</button>
            <div class="pill timer" id="nbTime">40</div>
            </div>
        </div>
        <div class="center" style="margin-top:10px">
            <div style="height:140px; display:grid; place-items:center;">
            <div id="nbArena" style="width:120px;height:120px;position:relative;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:4px;">
                <!-- symbol injected & positioned absolutely -->
                <div id="nbSym" style="position:absolute; inset:auto; font-weight:700; font-size:42px;">Press Start</div>
            </div>
            </div>
            <div id="nbBtns" class="grid two" style="max-width:520px;margin:8px auto 0"></div>
            <div class="muted" style="margin-top:6px">
            Hits <span id="nbHits">0</span> • False <span id="nbFalse">0</span> • Targets <span id="nbTargets">0</span>
            </div>
            <div id="nbFinish" class="finish hidden" style="margin-top:10px"></div>
        </div>
        </section>


        <!-- NUMBER MEMORY -->
        <section id="nmem" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Remember the number • High score <span id="nmBest">0</span></div>
                    <h2 style="margin:6px 0 0">Number Memory</h2>
                </div>
                <div class="row">
                    <button id="nmStart">Start</button>
                    <label class="pill"><input id="nmBackward" type="checkbox" /> Backward</label>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="nmShow" class="big">Press Start</div>
                <div class="row center" style="justify-content:center;margin-top:10px">
                    <input id="nmInput" type="text" inputmode="numeric" placeholder="Type the number"
                        style="max-width:260px" />
                    <button id="nmCheck">OK</button>
                </div>
                <div class="muted" style="margin-top:6px">Level: <span id="nmLevel">0</span></div>
                <div id="nmFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- READING COMPREHENSION -->
        <section id="read" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">One-word display → tricky question • Best WPM <span id="rcBest">0</span></div>
                    <h2 style="margin:6px 0 0">Reading Comprehension</h2>
                </div>
                <div class="row">
                    <select id="rcTopic"></select>
                    <label class="pill">WPM <span id="rcWpm">240</span></label>
                    <input id="rcSpeed" type="range" min="120" max="700" step="10" value="240" style="width:160px" />
                    <button id="rcStart">Start</button>
                    <button id="rcPause">Pause</button>
                    <button id="rcReset">Reset</button>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="rcWord" class="big" style="min-height:40px">Pick a topic and Start</div>
                <div id="rcQA" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- TANGO 6x6 -->
        <section id="tango" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">6×6 • 3 S & 3 M per row/col • no 3 in a row • '=' hints</div>
                    <h2 style="margin:6px 0 0">Tango</h2>
                </div>
                <div class="row">
                    <button id="tgNew">New</button>
                    <button id="tgHint">Hint</button>
                    <button id="tgCheck">Check</button>
                    <span class="pill">Legend: S=Sun, M=Moon</span>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="tgBoard" class="board"></div>
                <div id="tgMsg" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- FUTOSHIKI 4x4 -->
        <section id="futo" class="card hidden" role="tabpanel" aria-hidden="true">
        <div class="row" style="justify-content:space-between">
            <div>
            <div class="pill">4×4 • Fill 1–4 • Respect “‹/›/∧/∨” inequalities</div>
            <h2 style="margin:6px 0 0">Futoshiki 4×4</h2>
            </div>
            <div class="row">
            <button id="futoNew">New</button>
            <button id="futoCheck">Check</button>
            </div>
        </div>
        <div class="center" style="margin-top:10px">
            <div id="futoBoard" class="futo-board"></div>
            <div class="muted" style="margin-top:8px">Click cells to cycle 1–4. “‹/›” mean left cell is &lt; or &gt; right; “∧/∨” mean top &lt; or &gt; bottom.</div>
            <div class="muted" style="margin-top:8px">
Goal: Fill the 4×4 grid with numbers 1–4 so each row and column contains every number exactly once (no repeats).

Inequalities must hold:
‹ means left < right, › means left > right, ∧ means top < bottom, ∨ means top > bottom.

Givens are fixed (darker cells).

Controls: Click a cell to cycle 1 → 2 → 3 → 4 → (blank).

Tips: Start from the strongest “< / >” chains and rows/cols missing many numbers; use inequalities to eliminate candidates before filling.               
            </div>
            <div id="futoMsg" class="finish hidden" style="margin-top:10px"></div>
        </div>
        </section>



        <p class="muted" style="margin-top:16px">All games work offline. No accounts, no tracking. <a href="https://www.paypal.com/paypalme/PatrickReinbold" target="_blank" style="color: lightblue">💙 Tip jar here</a>.</p>
    </div>

    <script>
        // ---------- STORAGE
        const STORE_KEY = 'brainlab_state_v2';
        function loadState() { try { return JSON.parse(localStorage.getItem(STORE_KEY)) || { best: { math: 0, stroop: 0, nback: 0, nmem: 0 }, solved: [] } } catch (e) { return { best: { math: 0, stroop: 0, nback: 0, nmem: 0 }, solved: [] } } }
        function saveState(s) { localStorage.setItem(STORE_KEY, JSON.stringify(s)) }
        let STATE = loadState();
        // ensure new best slots exist
        STATE.best = STATE.best || {};
        for (const k of ['gng','estroop','nbmulti','futo']) if (!(k in STATE.best)) STATE.best[k] = 0;
        saveState(STATE);


        // ---------- TEASERS (expanded set)
        const TEASERS = [
            { q: "You have three labeled boxes: APPLES, ORANGES, MIXED. All labels are wrong. You may pick one fruit from one box. How do you relabel correctly?", a: "Pick one fruit from the MIXED box. Suppose you pull an apple. Then that box must be APPLES. The box labeled APPLES cannot be apples (labels are wrong) and cannot be mixed, so it must be ORANGES. The remaining box is MIXED." },
            { q: "Two trains start 120 km apart and head toward each other, each at 60 km/h. A bee flies back and forth between them at 90 km/h until the trains meet. Total distance flown?", a: "Time to meet = 120/(60+60)=1 hour. Bee flies 90 km." },
            { q: "A 5‑letter code word uses letters A, B, C, D, E exactly once. The third letter is a vowel; B is left of D; A is not adjacent to E. Give one valid word.", a: "One example: B A E C D." },
            { q: "You have 7‑ and 11‑minute hourglasses. Measure exactly 15 minutes.", a: "Start both. At 7: flip 7. At 11: flip 11 (7 has 3 left). When 7 empties (14): flip 11; after 1 minute = 15." },
            { q: "A number is divisible by 3, ends with 5, and digit sum is 12. What is it?", a: "75." },
            { q: "Five sit round a table. Alex between Bea and Cam. Dan not next to Alex. Eve sits two seats clockwise from Bea. Who sits between Dan and Eve?", a: "Cam, in one valid arrangement: Bea, Alex, Cam, Dan, Eve." },
            { q: "You drop a 1×1×1 cube into a bucket, fill to brim, then remove cube. Overflow, same, or drop?", a: "Drop. Removing cube removes displaced volume." },
            { q: "Pick a prime between 51 and 100 that is one less than a multiple of 6.", a: "Any of 53,59,71,83,89." },
            { q: "Smallest positive integer that leaves remainders 1,2,3 when divided by 2,3,4 respectively?", a: "11 (it's −1 mod lcm(2,3,4)=12)." },
            // new verbal riddles
            { q: "A man looks at a painting and says, 'Brothers and sisters, I have none, but that man's father is my father's son.' Who is in the painting?", a: "His son." },
            { q: "What 3‑letter word completes all: _IGHT (8), _EAD (lead), _ORE (ore) and becomes a new valid word each time?", a: "'L' → LIGHT, LEAD, LORE." },
            { q: "You buy a $10 item. You overpay with a $20 and receive $10 and the item. Later the cashier realizes the $20 was counterfeit and pays the store $20 from their own wallet. Total loss to the cashier?", a: "$20 (they lost a real $20 and the store lost nothing net)." },
            { q: "You have two ropes. Each burns in exactly 60 minutes but not at a consistent rate. How to measure 45 minutes?", a: "Light Rope A at both ends and Rope B at one end. When A finishes (30 min), light the other end of B (15 more) → 45." },
            { q: "Which weighs more: a kilo of feathers or a kilo of steel?", a: "Same mass; volume differs." },
            { q: "You meet two guards: one always lies, one always tells truth. One door leads to freedom. One question to ask one guard?", a: "Ask either: 'Which door would the other say is freedom?' Then go the other way." },
            { q: "A farmer needs to take a fox, a chicken, and grain across a river with a boat that holds one item at a time. How?", a: "Take chicken; return; take fox; bring chicken back; take grain; return; take chicken." },
            { q: "You have 8 balls, one is heavier, balance scale, find in 2 weighings. How?", a: "Weigh 3 vs 3. If equal, heavier is among remaining 2 → weigh 1 vs 1. Else take heavier group of 3 and weigh 1 vs 1, using logic to find the heavier." },
            { q: "A clock shows 3:15. What is the angle between hour and minute hands?", a: "At 3:15, minute at 90°. Hour hand at 97.5°. Angle 7.5°." }
        ];
        let idx = 0; const qEl = document.getElementById('teaserQ'); const aEl = document.getElementById('teaserA');
        const solvedEl = document.getElementById('teaserSolved'); const totalEl = document.getElementById('teaserTotal'); totalEl.textContent = TEASERS.length;
        function refreshSolved() { solvedEl.textContent = STATE.solved.length }
        function showTeaser(i) { const t = TEASERS[i % TEASERS.length]; qEl.textContent = t.q; aEl.textContent = t.a; document.getElementById('answerBox').open = false }
        showTeaser(idx); refreshSolved();

        document.getElementById('newTeaser').onclick = () => { idx = (idx + 1) % TEASERS.length; showTeaser(idx) };
        document.getElementById('reveal').onclick = () => { document.getElementById('answerBox').open = true }
        document.getElementById('markSolved').onclick = () => { if (!STATE.solved.includes(idx)) { STATE.solved.push(idx); saveState(STATE); refreshSolved(); } }

        // ---------- TABS
        const tabs = [...document.querySelectorAll('.tab')];
        tabs.forEach(t => t.addEventListener('click', () => {
            tabs.forEach(x => x.setAttribute('aria-selected', 'false'));
            t.setAttribute('aria-selected', 'true');
            const panel = t.dataset.panel;[...document.querySelectorAll('section[role="tabpanel"]')].forEach(sec => {
                const on = sec.id === panel; sec.classList.toggle('hidden', !on); sec.setAttribute('aria-hidden', (!on).toString());
            })
        }))

        // helpers
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a }

        // ---------- SPEED MATH
        const mathQ = document.getElementById('mathQ');
        const mathInput = document.getElementById('mathInput');
        const mathScoreEl = document.getElementById('mathScore');
        const mathStreakEl = document.getElementById('mathStreak');
        const mathFeedback = document.getElementById('mathFeedback');
        const mathTime = document.getElementById('mathTime');
        const mathBest = document.getElementById('mathBest'); mathBest.textContent = STATE.best.math;
        const mathFinish = document.getElementById('mathFinish');
        let mathTimer = null, mathLeft = 30, mathScore = 0, mathStreak = 0, truth = 0;
        function newMathQ() {
            const ops = ['+', '-', '×', '÷'];
            const op = ops[randInt(0, ops.length - 1)];
            let a = randInt(2, 25), b = randInt(2, 25);
            if (op === '÷') { truth = a; const prod = a * b; mathQ.textContent = `${prod} ÷ ${b}` }
            else if (op === '×') { truth = a * b; mathQ.textContent = `${a} × ${b}` }
            else if (op === '+') { truth = a + b; mathQ.textContent = `${a} + ${b}` }
            else { if (a < b) [a, b] = [b, a]; truth = a - b; mathQ.textContent = `${a} − ${b}` }
            mathQ.classList.add('flash'); setTimeout(() => mathQ.classList.remove('flash'), 180);
        }
        function endMath() {
            clearInterval(mathTimer); mathTimer = null; mathFeedback.textContent = '';
            const prevBest = STATE.best.math || 0; if (mathScore > prevBest) { STATE.best.math = mathScore; saveState(STATE); mathBest.textContent = STATE.best.math; }
            mathFinish.classList.remove('hidden');
            mathFinish.innerHTML = `Finished! Score <b>${mathScore}</b> • Best <b>${STATE.best.math}</b> <div style="margin-top:6px"><button onclick="(${startMath.toString()})()">Play again</button></div>`;
            mathQ.textContent = 'Done';
        }
        function startMath() {
            mathFinish.classList.add('hidden');
            mathLeft = 30; mathScore = 0; mathStreak = 0; mathScoreEl.textContent = '0'; mathStreakEl.textContent = '0'; mathTime.textContent = '30'; newMathQ(); mathInput.value = ''; mathInput.focus();
            if (mathTimer) clearInterval(mathTimer);
            mathTimer = setInterval(() => { mathLeft--; mathTime.textContent = String(mathLeft); if (mathLeft <= 0) { endMath() } }, 1000);
        }
        function checkMath() {
            const val = Number(mathInput.value);
            if (Number.isFinite(val) && val === truth) { mathScore++; mathStreak++; mathFeedback.textContent = '✔'; mathFeedback.className = 'ok'; newMathQ() } else { mathStreak = 0; mathFeedback.textContent = '✖'; mathFeedback.className = 'bad' }
            mathScoreEl.textContent = String(mathScore); mathStreakEl.textContent = String(mathStreak); mathInput.value = ''; mathInput.focus()
        }

        document.getElementById('mathStart').onclick = startMath;
        document.getElementById('mathCheck').onclick = checkMath;
        mathInput.addEventListener('keydown', e => { if (e.key === 'Enter') checkMath() });

        // ---------- STROOP
        const COLORS = [
            { name: 'RED', css: '#ef4444' },
            { name: 'BLUE', css: '#3b82f6' },
            { name: 'GREEN', css: '#22c55e' },
            { name: 'YELLOW', css: '#eab308' },
            { name: 'PURPLE', css: '#a855f7' }
        ];
        const stroopWord = document.getElementById('stroopWord');
        const stroopBtns = document.getElementById('stroopBtns');
        const stroopScoreEl = document.getElementById('stroopScore');
        const stroopAccEl = document.getElementById('stroopAcc');
        const stroopTime = document.getElementById('stroopTime');
        const stroopBest = document.getElementById('stroopBest'); stroopBest.textContent = STATE.best.stroop;
        const stroopFinish = document.getElementById('stroopFinish');
        let stroopTimer = null, stroopLeft = 30, stroopScore = 0, stroopTries = 0, stroopAnswer = '';
        function setupStroopButtons() { stroopBtns.innerHTML = ''; COLORS.forEach(c => { const b = document.createElement('button'); b.textContent = c.name; b.style.borderColor = c.css; b.onclick = () => pickStroop(c.name); stroopBtns.appendChild(b) }) }
        function newStroop() { const word = COLORS[Math.floor(Math.random() * COLORS.length)].name; const ink = COLORS[Math.floor(Math.random() * COLORS.length)]; stroopAnswer = ink.name; stroopWord.textContent = word; stroopWord.style.color = ink.css; stroopWord.classList.add('flash'); setTimeout(() => stroopWord.classList.remove('flash'), 180) }
        function pickStroop(name) { if (!stroopTimer) return; stroopTries++; if (name === stroopAnswer) stroopScore++; stroopScoreEl.textContent = String(stroopScore); stroopAccEl.textContent = `${Math.round(100 * (stroopTries ? stroopScore / stroopTries : 0))}%`; newStroop() }
        function endStroop() {
            clearInterval(stroopTimer); stroopTimer = null;
            const prevBest = STATE.best.stroop || 0; if (stroopScore > prevBest) { STATE.best.stroop = stroopScore; saveState(STATE); stroopBest.textContent = STATE.best.stroop; }
            stroopFinish.classList.remove('hidden');
            stroopFinish.innerHTML = `Finished! Score <b>${stroopScore}</b> • Acc <b>${Math.round(100 * (stroopTries ? stroopScore / stroopTries : 0))}%</b> • Best <b>${STATE.best.stroop}</b> <div style="margin-top:6px"><button onclick="(${startStroop.toString()})()">Play again</button></div>`;
            stroopWord.textContent = 'Done';
        }
        function startStroop() {
            stroopFinish.classList.add('hidden');
            stroopLeft = 30; stroopScore = 0; stroopTries = 0; stroopScoreEl.textContent = '0'; stroopAccEl.textContent = '0%'; stroopTime.textContent = '30'; newStroop(); if (stroopTimer) clearInterval(stroopTimer); stroopTimer = setInterval(() => { stroopLeft--; stroopTime.textContent = String(stroopLeft); if (stroopLeft <= 0) endStroop() }, 1000)
        }
        setupStroopButtons();
        document.getElementById('stroopStart').onclick = startStroop;






        // ---------- GO/NO-GO ----------
        const gngStim = document.getElementById('gngStim');
        const gngStart = document.getElementById('gngStart');
        const gngGoBtn = document.getElementById('gngGoBtn');
        const gngProb = document.getElementById('gngProb');
        const gngProbLbl = document.getElementById('gngProbLbl');
        const gngCount = document.getElementById('gngCount');
        const gngHits = document.getElementById('gngHits');
        const gngFA = document.getElementById('gngFA');
        const gngAcc = document.getElementById('gngAcc');
        const gngBest = document.getElementById('gngBest');
        const gngFinish = document.getElementById('gngFinish');
        gngBest.textContent = `${STATE.best.gng||0}%`;
        let gngTimer=null, gngTrial=0, gngTotal=60, gngNoGoSet=new Set(), gngHit=0, gngFalse=0, gngAllow=false, gWasNoGo=false;

        gngProb.oninput=()=>gngProbLbl.textContent=gngProb.value;

        function gngPlanTrials(pNoGo=20){ // percent
        gngNoGoSet.clear();
        const nNoGo = Math.round(gngTotal * pNoGo/100);
        const pool=[...Array(gngTotal).keys()];
        for(let i=pool.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [pool[i],pool[j]]=[pool[j],pool[i]] }
        pool.slice(0,nNoGo).forEach(i=>gngNoGoSet.add(i));
        }
        function gngShow() {
        if (gngTrial>=gngTotal){ gngEnd(); return; }
        const noGo = gngNoGoSet.has(gngTrial);
        gWasNoGo = noGo;
        gngStim.textContent = noGo ? 'NO-GO' : 'GO';
        gngStim.style.color = noGo ? '#ef4444' : '#22c55e';
        gngStim.classList.add('flash'); setTimeout(()=>gngStim.classList.remove('flash'),160);
        gngAllow=true;
        gngCount.textContent = `${gngTrial+1}/${gngTotal}`;
        gngTrial++;
        }
        function gngPress(){
        if(!gngTimer || !gngAllow) return;
        if(!gWasNoGo){ gngHit++; } else { gngFalse++; }
        gngHits.textContent = String(gngHit); gngFA.textContent = String(gngFalse);
        const acc = Math.round(100*(gngHit/(gngTrial - gngNoGoSet.has(gngTrial-1) ? (gngTrial - 1 - gngNoGoSet.size) : (gngTrial - gngNoGoSet.size) || 1)));
        gngAcc.textContent = `${Math.max(0, Math.min(100, acc))}%`;
        gngAllow=false;
        }
        function gngEnd(){
        clearInterval(gngTimer); gngTimer=null; gngAllow=false;
        const goTrials = gngTotal - gngNoGoSet.size;
        const acc = Math.round(100*(gngHit/Math.max(1,goTrials)));
        if(acc>(STATE.best.gng||0)){ STATE.best.gng=acc; saveState(STATE); gngBest.textContent=`${acc}%`; }
        gngFinish.classList.remove('hidden');
        gngFinish.innerHTML = `Finished! Go accuracy <b>${acc}%</b> • Hits ${gngHit}/${goTrials} • False alarms ${gngFalse}
            <div style="margin-top:6px"><button onclick="(${gngStartRun.toString()})()">Play again</button></div>`;
        gngStim.textContent='Done';
        }
        function gngStartRun(){
        gngFinish.classList.add('hidden'); gngTrial=0; gngHit=0; gngFalse=0; gngHits.textContent='0'; gngFA.textContent='0'; gngAcc.textContent='0%';
        gngPlanTrials(Number(gngProb.value));
        if(gngTimer) clearInterval(gngTimer);
        gngShow(); gngTimer=setInterval(gngShow, 800); // 0.8 s per trial
        }
        gngStart.onclick=gngStartRun;
        gngGoBtn.onclick=gngPress;
        window.addEventListener('keydown', e=>{ if(document.getElementById('gng').getAttribute('aria-hidden')==='false' && e.key.toLowerCase()==='g'){ gngPress(); }});








        // ---------- EMOTIONAL STROOP ----------
        const EMO_WORDS = ['ANGER','JOY','FEAR','HAPPY','SAD','LOVE','PANIC','PEACE','HATE','SMILE'];
        const esWord = document.getElementById('esWord');
        const esBtns = document.getElementById('esBtns');
        const esScoreEl = document.getElementById('esScore');
        const esAccEl = document.getElementById('esAcc');
        const esTime = document.getElementById('esTime');
        const esBest = document.getElementById('esBest'); esBest.textContent = STATE.best.estroop||0;
        const esFinish = document.getElementById('esFinish');
        let esTimer=null, esLeft=30, esScore=0, esTries=0, esAnswer='';

        function esSetupButtons(){ esBtns.innerHTML=''; COLORS.forEach(c=>{ const b=document.createElement('button'); b.textContent=c.name; b.style.borderColor=c.css; b.onclick=()=>esPick(c.name); esBtns.appendChild(b); }); }
        function esNew(){
        const word = EMO_WORDS[(Math.random()*EMO_WORDS.length)|0];
        const ink = COLORS[(Math.random()*COLORS.length)|0];
        esAnswer = ink.name; esWord.textContent=word; esWord.style.color=ink.css;
        esWord.classList.add('flash'); setTimeout(()=>esWord.classList.remove('flash'),160);
        }
        function esPick(name){
        if(!esTimer) return; esTries++; if(name===esAnswer) esScore++;
        esScoreEl.textContent=String(esScore); esAccEl.textContent=`${Math.round(100*(esScore/(esTries||1)))}%`; esNew();
        }
        function esEnd(){
        clearInterval(esTimer); esTimer=null;
        if(esScore>(STATE.best.estroop||0)){ STATE.best.estroop=esScore; saveState(STATE); esBest.textContent=STATE.best.estroop; }
        esFinish.classList.remove('hidden');
        esFinish.innerHTML = `Finished! Score <b>${esScore}</b> • Acc <b>${Math.round(100*(esScore/(esTries||1)))}%</b> • Best <b>${STATE.best.estroop}</b>
            <div style="margin-top:6px"><button onclick="(${esStart.toString()})()">Play again</button></div>`;
        esWord.textContent='Done';
        }
        function esStart(){
        esFinish.classList.add('hidden'); esLeft=30; esScore=0; esTries=0; esScoreEl.textContent='0'; esAccEl.textContent='0%'; esTime.textContent='30';
        esNew(); if(esTimer) clearInterval(esTimer);
        esTimer=setInterval(()=>{ esLeft--; esTime.textContent=String(esLeft); if(esLeft<=0) esEnd(); },1000);
        }
        esSetupButtons(); document.getElementById('esStart').onclick=esStart;






        // ---------- MULTI N-BACK ----------
        const nbNEl = document.getElementById('nbN');
        const nbSet = document.getElementById('nbSet');
        const nbBtns = document.getElementById('nbBtns');
        const nbStart = document.getElementById('nbStart');
        const nbTime = document.getElementById('nbTime');
        const nbHits = document.getElementById('nbHits');
        const nbFalse = document.getElementById('nbFalse');
        const nbTargets = document.getElementById('nbTargets');
        const nbBest = document.getElementById('nbBest');
        const nbFinish = document.getElementById('nbFinish');
        const nbSym = document.getElementById('nbSym');
        nbBest.textContent = STATE.best.nbmulti||0;
        const LETTERS_SET = 'ABCDEFGHJKLMNPQRSTUVWXZ'.split(''); // no I/O/Y
        const DIGITS_SET = '0123456789'.split('');
        const POSITIONS = [...Array(9).keys()]; // 0..8 on 3x3

        let nbTimer=null, nbSeq=[], nbIdx=0, nbLen=36, nbHit=0, nbFalseC=0, nbTgtCount=0, nbAllow=false, nbActiveTargets=null;
        function nbFeatureList(){
        return [
            document.getElementById('nbFeatSymbol').checked ? 'symbol' : null,
            document.getElementById('nbFeatColor').checked ? 'color' : null,
            document.getElementById('nbFeatSize').checked ? 'size' : null,
            document.getElementById('nbFeatPos').checked ? 'pos' : null,
        ].filter(Boolean);
        }
        function nbRandFrom(a){ return a[(Math.random()*a.length)|0] }
        function nbRandSymbol(){ return (nbSet.value==='Digits'? DIGITS_SET: LETTERS_SET)[(Math.random()* (nbSet.value==='Digits'? DIGITS_SET.length: LETTERS_SET.length))|0] }
        function nbRandColor(){ return nbRandFrom(COLORS).name }
        function nbRandSize(){ return nbRandFrom([32,42,56]) } // px font size
        function nbGridPosCell(idx){ // 0..8 to CSS top/left in grid
        const r = Math.floor(idx/3), c = idx%3;
        return {top: `${r*40}px`, left: `${c*40}px`};
        }
        function nbMakeItem(prevN){
        const feats = nbFeatureList();
        const symbol = nbRandSymbol(), color=nbRandColor(), size=nbRandSize(), pos=nbRandFrom(POSITIONS);
        const base = {symbol,color,size,pos};
        if(nbSeq.length < prevN) return {...base, targets: []};
        // choose at most ONE target feature per trial to disambiguate response
        if(feats.length===0) return {...base, targets: []};
        const makeTarget = Math.random() < 0.35; // ~35% of trials are targets
        if(!makeTarget) return {...base, targets: []};
        const pick = nbRandFrom(feats);
        const past = nbSeq[nbSeq.length - prevN];
        const forced = {...base};
        forced[pick] = past[pick];
        return {...forced, targets: [pick]};
        }
        function nbPlan(){
        nbSeq.length=0; nbIdx=0; nbHit=0; nbFalseC=0; nbTgtCount=0; nbAllow=false; nbActiveTargets=null;
        const N = Number(nbNEl.value);
        for(let i=0;i<nbLen;i++){
            const it = nbMakeItem(N);
            nbSeq.push(it);
            if(it.targets.length) nbTgtCount++;
        }
        nbTargets.textContent = String(nbTgtCount);
        }
        function nbRender(item){
        nbSym.textContent = item.symbol;
        const c = COLORS.find(x=>x.name===item.color) || COLORS[0];
        nbSym.style.color = c.css;
        nbSym.style.fontSize = `${item.size}px`;
        const posCSS = nbGridPosCell(item.pos);
        nbSym.style.top = posCSS.top; nbSym.style.left = posCSS.left;
        nbSym.classList.add('flash'); setTimeout(()=>nbSym.classList.remove('flash'),160);
        }
        function nbShow(){
        if(nbIdx>=nbSeq.length){ nbEnd(); return; }
        const it = nbSeq[nbIdx]; nbActiveTargets = it.targets; nbRender(it);
        nbAllow = true; nbIdx++; nbTime.textContent = String(nbSeq.length - nbIdx);
        }
        function nbClick(feature){
        if(!nbTimer || !nbAllow) return;
        const isTarget = (nbActiveTargets||[]).includes(feature);
        if(isTarget){ nbHit++; } else { nbFalseC++; }
        nbHits.textContent = String(nbHit); nbFalse.textContent = String(nbFalseC);
        nbAllow = false;
        }
        function nbButtonsRefresh(){
        const feats = nbFeatureList(); nbBtns.innerHTML='';
        feats.forEach(f=>{
            const label = (f==='symbol'?'Symbol': f==='color'?'Color': f==='size'?'Size':'Position');
            const btn=document.createElement('button');
            btn.textContent = label + ' Match';
            btn.onclick=()=>nbClick(f);
            nbBtns.appendChild(btn);
        });
        }
        ['nbFeatSymbol','nbFeatColor','nbFeatSize','nbFeatPos','nbSet'].forEach(id=>{
        document.getElementById(id).addEventListener('change', nbButtonsRefresh);
        });
        function nbEnd(){
        clearInterval(nbTimer); nbTimer=null; nbAllow=false;
        if(nbHit>(STATE.best.nbmulti||0)){ STATE.best.nbmulti=nbHit; saveState(STATE); nbBest.textContent=STATE.best.nbmulti; }
        nbFinish.classList.remove('hidden');
        nbFinish.innerHTML = `Finished! Hits <b>${nbHit}</b> / Targets <b>${nbTgtCount}</b> • False <b>${nbFalseC}</b>
            <div style="margin-top:6px"><button onclick="(${nbStartRun.toString()})()">Play again</button></div>`;
        nbSym.textContent='Done';
        }
        function nbStartRun(){
        nbFinish.classList.add('hidden'); nbButtonsRefresh();
        nbPlan(); nbHits.textContent='0'; nbFalse.textContent='0'; nbTime.textContent=String(nbLen);
        if(nbTimer) clearInterval(nbTimer);
        nbShow(); nbTimer=setInterval(nbShow, 1000);
        }
        nbStart.onclick = nbStartRun;
        nbButtonsRefresh();








        // ---------- NUMBER MEMORY
        const nmShow = document.getElementById('nmShow');
        const nmInput = document.getElementById('nmInput');
        const nmLevelEl = document.getElementById('nmLevel');
        const nmBestEl = document.getElementById('nmBest'); nmBestEl.textContent = STATE.best.nmem;
        const nmFinish = document.getElementById('nmFinish');
        let nmLevel = 0, nmCurrent = '';
        function randDigits(n) { let s = ''; for (let i = 0; i < n; i++) s += String(Math.floor(Math.random() * 10)); return s }
        function nmStart() { nmFinish.classList.add('hidden'); nmLevel = 1; nmLevelEl.textContent = '1'; nmNext() }
        function nmNext() { nmCurrent = randDigits(nmLevel); nmShow.textContent = nmCurrent; nmShow.classList.add('flash'); setTimeout(() => { nmShow.textContent = '…'; }, 900); nmInput.value = ''; nmInput.focus() }
        function reverseStr(s){ return s.split('').reverse().join('') }
        function nmCheck() {
            const backward = document.getElementById('nmBackward').checked;
            const expected = backward ? reverseStr(nmCurrent) : nmCurrent;
            const ok = nmInput.value.trim() === expected;
            if (ok) {
                nmLevel++; nmLevelEl.textContent = String(nmLevel); nmNext();
            } else {
                const bestPrev = STATE.best.nmem || 0;
                const achieved = Math.max(1, nmLevel - 1);
                if (achieved > bestPrev) { STATE.best.nmem = achieved; saveState(STATE); nmBestEl.textContent = STATE.best.nmem }
                nmFinish.classList.remove('hidden');
                nmFinish.innerHTML = `Finished! Level reached <b>${achieved}</b> • Best <b>${STATE.best.nmem}</b>
                <div style="margin-top:6px"><button onclick="(${nmStart.toString()})()">Play again</button></div>`;
                nmShow.textContent = 'Done';
            }
        }


        document.getElementById('nmStart').onclick = nmStart;
        document.getElementById('nmCheck').onclick = nmCheck;
        nmInput.addEventListener('keydown', e => { if (e.key === 'Enter') nmCheck() });


        // ---------- READING COMPREHENSION
        if (!STATE.best.rc) STATE.best.rc = {};
        const RC_TOPICS = window.RC_TOPICS || [];

        const rcTopicSel = document.getElementById('rcTopic');
        const rcWord = document.getElementById('rcWord');
        const rcQA = document.getElementById('rcQA');
        const rcBestEl = document.getElementById('rcBest');
        const rcSpeed = document.getElementById('rcSpeed');
        const rcWpm = document.getElementById('rcWpm');
        const rcStart = document.getElementById('rcStart');
        const rcPause = document.getElementById('rcPause');
        const rcReset = document.getElementById('rcReset');

        let rcTimer = null, rcIdx = 0, rcWords = [], rcPaused = false;

        function rcFillTopics() {
            rcTopicSel.innerHTML = '';
            RC_TOPICS.forEach((t, i) => {
                const o = document.createElement('option');
                o.value = String(i); o.textContent = t.topic;
                rcTopicSel.appendChild(o);
            });
            rcUpdateBest();
        }
        function rcUpdateBest() {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            const best = (STATE.best.rc[t.topic] || 0);
            rcBestEl.textContent = best;
        }
        function rcShowNext() {
            if (rcIdx >= rcWords.length) {
                clearInterval(rcTimer); rcTimer = null;
                rcAsk(); return;
            }
            rcWord.textContent = rcWords[rcIdx++];
            rcWord.classList.add('flash'); setTimeout(() => rcWord.classList.remove('flash'), 150);
        }
        function rcStartRun() {
            rcQA.classList.add('hidden'); rcQA.innerHTML = '';
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            rcWords = t.text.split(/\s+/);
            rcIdx = 0; rcShowNext(); rcPaused = false;
            if (rcTimer) clearInterval(rcTimer);
            const ms = Math.max(60, Math.round(60000 / Number(rcSpeed.value))); // speedable
            rcTimer = setInterval(rcShowNext, ms);
        }
        function rcPauseRun() {
            if (!rcTimer) { return }
            clearInterval(rcTimer); rcTimer = null; rcPaused = true;
            rcWord.textContent += ' ▌';
        }
        function rcResetRun() {
            if (rcTimer) { clearInterval(rcTimer); rcTimer = null }
            rcWord.textContent = 'Pick a topic and Start';
            rcQA.classList.add('hidden');
        }
        function rcAsk() {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            rcWord.textContent = '?';
            rcQA.classList.remove('hidden');
            const wrap = document.createElement('div');
            wrap.innerHTML = `<div><b>${t.q}</b></div>`;
            t.choices.forEach((c, i) => {
                const b = document.createElement('button');
                b.textContent = c; b.style.margin = '6px';
                b.onclick = () => rcAnswer(i);
                wrap.appendChild(b);
            });
            rcQA.innerHTML = ''; rcQA.appendChild(wrap);
        }
        function rcAnswer(i) {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            const correct = i === t.answer;
            rcQA.innerHTML = `You are <b class="${correct ? 'ok' : 'bad'}">${correct ? 'correct' : 'wrong'}</b>.` + (correct ? ' Nice.' : '');
            if (correct) {
                const wpm = Number(rcSpeed.value);
                const best = STATE.best.rc[t.topic] || 0;
                if (wpm > best) { STATE.best.rc[t.topic] = wpm; saveState(STATE); rcBestEl.textContent = wpm }
            }
        }
        rcSpeed.oninput = () => { rcWpm.textContent = rcSpeed.value; if (rcTimer) { clearInterval(rcTimer); const ms = Math.max(60, Math.round(60000 / Number(rcSpeed.value))); rcTimer = setInterval(rcShowNext, ms) } };
        rcStart.onclick = rcStartRun; rcPause.onclick = rcPauseRun; rcReset.onclick = rcResetRun; rcTopicSel.onchange = rcUpdateBest;
        rcFillTopics();


        /* ------------------- TANGO (Takuzu 6×6) ------------------- */
        /* Symbols */
        const TG = 6, S = 'S', M = 'M';
        const tgBoard = document.getElementById('tgBoard'), tgMsg = document.getElementById('tgMsg');
        let tgCells = [], tgHEq = [], tgVEq = [], tgHNeq = [], tgVNeq = [], tgSolution = [], tgGivens = [];

        /* -------- utils -------- */
        const rng = () => Math.random();
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (rng() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } return a }
        function empty() { return Array.from({ length: TG }, () => Array(TG).fill(null)) }
        function clone(g) { return g.map(r => r.slice()) }
        function isFull(g) { return g.every(r => r.every(v => v != null)) }
        function rowCount(g, r, v) { return g[r].filter(x => x === v).length }
        function colCount(g, c, v) { let n = 0; for (let r = 0; r < TG; r++) if (g[r][c] === v) n++; return n }
        function eq(a, b) { return JSON.stringify(a) === JSON.stringify(b) }

        /* hard/soft constraints */
        function noTriples(g) {
            // returns true if any illegal triple exists
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG - 2; c++) {
                const a = g[r][c], b = g[r][c + 1], d = g[r][c + 2];
                if (a && a === b && b === d) return true;
            }
            for (let c = 0; c < TG; c++) for (let r = 0; r < TG - 2; r++) {
                const a = g[r][c], b = g[r + 1][c], d = g[r + 2][c];
                if (a && a === b && b === d) return true;
            }
            return false;
        }
        function countsOK(g) {
            for (let r = 0; r < TG; r++) {
                const s = rowCount(g, r, S), m = rowCount(g, r, M);
                if (s > 3 || m > 3) return false;
            }
            for (let c = 0; c < TG; c++) {
                let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (g[r][c] === S) s++; else if (g[r][c] === M) m++; }
                if (s > 3 || m > 3) return false;
            }
            return true;
        }
        function countsExact(g) {
            for (let r = 0; r < TG; r++) if (rowCount(g, r, S) !== 3 || rowCount(g, r, M) !== 3) return false;
            for (let c = 0; c < TG; c++) {
                let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (g[r][c] === S) s++; else if (g[r][c] === M) m++; }
                if (s !== 3 || m !== 3) return false;
            }
            return true;
        }
        function rowsUnique(g) {
            for (let i = 0; i < TG; i++) for (let j = i + 1; j < TG; j++) {
                let comp = true;
                for (let k = 0; k < TG; k++) { const a = g[i][k], b = g[j][k]; if (a == null || b == null || a !== b) { comp = false; break } }
                if (comp) return false;
            } return true;
        }
        function colsUnique(g) {
            for (let i = 0; i < TG; i++) for (let j = i + 1; j < TG; j++) {
                let comp = true;
                for (let r = 0; r < TG; r++) { const a = g[r][i], b = g[r][j]; if (a == null || b == null || a !== b) { comp = false; break } }
                if (comp) return false;
            } return true;
        }
        function legalLocal(g, r, c) {
            if (!countsOK(g)) return false;
            // local triple checks around (r,c)
            for (let k = c - 2; k <= c; k++) {
                if (k < 0 || k + 2 >= TG) continue;
                const a = g[r][k], b = g[r][k + 1], d = g[r][k + 2];
                if (a && b && d && a === b && b === d) return false;
            }
            for (let k = r - 2; k <= r; k++) {
                if (k < 0 || k + 2 >= TG) continue;
                const a = g[k][c], b = g[k + 1][c], d = g[k + 2][c];
                if (a && b && d && a === b && b === d) return false;
            }
            // if row full -> exact + unique vs other full rows
            if (g[r].every(x => x != null)) {
                if (rowCount(g, r, S) !== 3 || rowCount(g, r, M) !== 3) return false;
                for (let rr = 0; rr < TG; rr++) if (rr !== r && g[rr].every(x => x != null)) {
                    if (g[rr].every((x, k) => x === g[r][k])) return false;
                }
            }
            // if column full -> exact + unique vs other full cols
            let cFull = true; for (let rr = 0; rr < TG; rr++) if (g[rr][c] == null) { cFull = false; break }
            if (cFull) {
                let s = 0, m = 0; for (let rr = 0; rr < TG; rr++) { if (g[rr][c] === S) s++; else if (g[rr][c] === M) m++; }
                if (s !== 3 || m !== 3) return false;
                for (let cc = 0; cc < TG; cc++) if (cc !== c) {
                    let otherFull = true, same = true;
                    for (let rr = 0; rr < TG; rr++) { if (g[rr][cc] == null) { otherFull = false; break } }
                    if (otherFull) { for (let rr = 0; rr < TG; rr++) { if (g[rr][cc] !== g[rr][c]) { same = false; break } } if (same) return false; }
                }
            }
            return true;
        }

        /* -------- generator: random solved board (backtracking + randomized order) -------- */
        function genSolved() {
            const g = empty();
            const coords = []; for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) coords.push([r, c]);
            shuffle(coords);
            function back(i) {
                if (i === coords.length) { return !noTriples(g) && countsExact(g) && rowsUnique(g) && colsUnique(g) }
                const [r, c] = coords[i];
                const vals = rng() < 0.5 ? [S, M] : [M, S];
                for (const v of vals) {
                    g[r][c] = v;
                    if (legalLocal(g, r, c) && back(i + 1)) return true;
                }
                g[r][c] = null; return false;
            }
            if (!back(0)) return genSolved(); // extremely selten
            return g;
        }

        /* -------- logic solver (deterministic Takuzu steps for hints & carving) --------
           Regeln: (1) keine 3 in Folge -> XX_ -> XXO; X_X -> O; (2) Zeilen/Spalten auffüllen wenn 3 erreicht;
           (3) Gegen identische vollendete Zeilen/Spalten: offene Felder müssen Gegensätze sein. */
        function solveByLogic(g) {
            const grid = clone(g);
            const HEq = empty(), VEq = empty(), HNeq = empty(), VNeq = empty(); // overlays (= / ×)
            let changed = true, guard = 0;
            function setCell(r, c, val, mark) {
                if (grid[r][c] == null) {
                    grid[r][c] = val;
                    if (mark) {
                        if (mark.hneq != null) HNeq[r][mark.hneq] = '×';
                        if (mark.vneq != null) VNeq[mark.vneq][c] = '×';
                        if (mark.heq != null) HEq[r][mark.heq] = '=';
                        if (mark.veq != null) VEq[mark.veq][c] = '=';
                    }
                }
            }
            while (changed && guard++ < 600) {
                changed = false;

                // A) Triples verhindern – Reihen
                for (let r = 0; r < TG; r++) for (let c = 0; c < TG - 2; c++) {
                    const a = grid[r][c], b = grid[r][c + 1], d = grid[r][c + 2];
                    if (a != null && b != null && d == null && a === b) { setCell(r, c + 2, a === S ? M : S, { hneq: c + 1 }); changed = true }
                    if (a == null && b != null && d != null && b === d) { setCell(r, c, b === S ? M : S, { hneq: c }); changed = true }
                    if (a != null && b == null && d != null && a === d) { setCell(r, c + 1, a === S ? M : S, { hneq: c + 1 }); changed = true }
                }
                // A) Triples verhindern – Spalten
                for (let c = 0; c < TG; c++) for (let r = 0; r < TG - 2; r++) {
                    const a = grid[r][c], b = grid[r + 1][c], d = grid[r + 2][c];
                    if (a != null && b != null && d == null && a === b) { setCell(r + 2, c, a === S ? M : S, { vneq: r + 1 }); changed = true }
                    if (a == null && b != null && d != null && b === d) { setCell(r, c, b === S ? M : S, { vneq: r }); changed = true }
                    if (a != null && b == null && d != null && a === d) { setCell(r + 1, c, a === S ? M : S, { vneq: r + 1 }); changed = true }
                }

                // B) 3 pro Zeile/Spalte erzwingen
                for (let r = 0; r < TG; r++) {
                    const s = rowCount(grid, r, S), m = rowCount(grid, r, M);
                    if (s === 3) { for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, M); changed = true } }
                    if (m === 3) { for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, S); changed = true } }
                }
                for (let c = 0; c < TG; c++) {
                    let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (grid[r][c] === S) s++; else if (grid[r][c] === M) m++; }
                    if (s === 3) { for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, M); changed = true } }
                    if (m === 3) { for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, S); changed = true } }
                }

                // C) Gegen identische fertige Zeilen/Spalten absichern
                // Zeilen
                for (let r = 0; r < TG; r++) {
                    if (grid[r].every(x => x != null)) continue;
                    for (let rr = 0; rr < TG; rr++) {
                        if (rr === r) continue;
                        if (!grid[rr].every(x => x != null)) continue; // nur gegen fertige vergleichen
                        let compatible = true;
                        for (let c = 0; c < TG; c++) { if (grid[r][c] != null && grid[r][c] !== grid[rr][c]) { compatible = false; break } }
                        if (compatible) {
                            for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, grid[rr][c] === S ? M : S, {}); changed = true }
                        }
                    }
                }
                // Spalten
                for (let c = 0; c < TG; c++) {
                    let colFull = true; for (let r = 0; r < TG; r++) if (grid[r][c] == null) { colFull = false; break }
                    if (colFull) continue;
                    for (let cc = 0; cc < TG; cc++) {
                        if (cc === c) continue;
                        let otherFull = true; for (let r = 0; r < TG; r++) if (grid[r][cc] == null) { otherFull = false; break }
                        if (!otherFull) continue;
                        let compatible = true;
                        for (let r = 0; r < TG; r++) { const a = grid[r][c], b = grid[r][cc]; if (a != null && b != null && a !== b) { compatible = false; break } }
                        if (compatible) {
                            for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, grid[r][cc] === S ? M : S, {}); changed = true }
                        }
                    }
                }
            }
            const solved = isFull(grid) && !noTriples(grid) && countsExact(grid) && rowsUnique(grid) && colsUnique(grid);
            return { grid, HEq, VEq, HNeq, VNeq, solved };
        }

        /* -------- full solver (backtracking) to check uniqueness -------- */
        function firstEmpty(g) {
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) if (g[r][c] == null) return [r, c];
            return null;
        }
        function tryValuesRandom() { return rng() < 0.5 ? [S, M] : [M, S]; }
        function solveBacktrack(grid, stopAt = 1) {
            let count = 0, last = null;
            const g = clone(grid);
            function dfs() {
                if (noTriples(g) || !countsOK(g)) return;
                // simple forward: if any row/col full, check exact+unique against existing full ones
                // (already partly covered in legalLocal when placing, but we pick empties directly here)
                const e = firstEmpty(g);
                if (!e) {
                    if (countsExact(g) && rowsUnique(g) && colsUnique(g)) { count++; last = clone(g); }
                    return;
                }
                const [r, c] = e, vals = tryValuesRandom();
                for (const v of vals) {
                    g[r][c] = v;
                    if (legalLocal(g, r, c)) {
                        dfs();
                        if (count >= stopAt) { g[r][c] = null; return; }
                    }
                    g[r][c] = null;
                }
            }
            dfs();
            return { count, solution: last };
        }

        /* -------- Carving: entferne nur Felder, die logisch herleitbar sind UND die Eindeutigkeit erhalten -------- */
        function carveFromSolution(sol) {
            let puzzle = clone(sol);
            const cells = []; for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) cells.push([r, c]);
            shuffle(cells);

            let bestHEq = empty(), bestVEq = empty(), bestHNeq = empty(), bestVNeq = empty();

            for (const [r, c] of cells) {
                const keep = puzzle[r][c]; puzzle[r][c] = null;

                // 1) mit Logik auflösen
                const step = solveByLogic(puzzle);
                // 2) wenn Logik vollständig zur selben Lösung führt UND eindeutig bleibt, behalten
                if (step.solved && eq(step.grid, sol)) {
                    const uniq = solveBacktrack(puzzle, 2);
                    if (uniq.count === 1) {
                        bestHEq = step.HEq; bestVEq = step.VEq; bestHNeq = step.HNeq; bestVNeq = step.VNeq;
                        continue; // Entfernung akzeptiert
                    }
                }
                // sonst rückgängig
                puzzle[r][c] = keep;
            }
            return { puzzle, HEq: bestHEq, VEq: bestVEq, HNeq: bestHNeq, VNeq: bestVNeq };
        }

        /* -------- UI -------- */
        function renderBoard(grid, HEq, VEq, HNeq, VNeq) {
            tgBoard.innerHTML = ''; tgCells = []; tgHEq = HEq; tgVEq = VEq; tgHNeq = HNeq; tgVNeq = VNeq;
            for (let r = 0; r < TG; r++) {
                for (let c = 0; c < TG; c++) {
                    const d = document.createElement('div'); d.className = 'cell'; d.dataset.r = r; d.dataset.c = c;
                    const v = grid[r][c]; d.textContent = v ? v : '';
                    if (v != null) d.dataset.lock = '1';
                    if (HEq[r][c] === '=') d.classList.add('eq-right');
                    if (VEq[r][c] === '=') d.classList.add('eq-down');
                    if (HNeq[r][c] === '×') d.classList.add('neq-right');
                    if (VNeq[r][c] === '×') d.classList.add('neq-down');
                    d.onclick = () => { if (d.dataset.lock === '1') return; const cur = d.textContent; d.textContent = cur === '' ? S : cur === S ? M : '' };
                    tgBoard.appendChild(d);
                    if (!tgCells[r]) tgCells[r] = []; tgCells[r][c] = d;
                }
            }
        }
        function readGrid() {
            const g = empty();
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                const t = tgCells[r][c].textContent; g[r][c] = t === '' ? null : (t === S ? S : M);
            }
            return g;
        }
        function say(msg, good) { tgMsg.classList.remove('hidden'); tgMsg.innerHTML = `<span class="${good ? 'ok' : 'bad'}">${msg}</span>` }

        /* Check */
        function tgCheck() {
            const g = readGrid();
            if (!countsOK(g)) return say('Max 3 von S/M pro Zeile/Spalte nicht überschreiten.', false);
            if (noTriples(g)) return say('Verbotene Dreierfolge gefunden.', false);
            // Soft-Warnungen gegen die Overlay-Hinweise
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                if (tgHEq[r][c] === '=' && g[r][c] != null && c + 1 < TG && g[r][c + 1] != null && g[r][c] !== g[r][c + 1]) return say('Hinweis "=" verletzt.', false);
                if (tgVEq[r][c] === '=' && g[r][c] != null && r + 1 < TG && g[r + 1][c] != null && g[r][c] !== g[r + 1][c]) return say('Hinweis "=" verletzt.', false);
                if (tgHNeq[r][c] === '×' && g[r][c] != null && c + 1 < TG && g[r][c + 1] != null && g[r][c] === g[r][c + 1]) return say('Hinweis "×" verletzt.', false);
                if (tgVNeq[r][c] === '×' && g[r][c] != null && r + 1 < TG && g[r + 1][c] != null && g[r][c] === g[r + 1][c]) return say('Hinweis "×" verletzt.', false);
            }
            if (isFull(g)) {
                if (!countsExact(g)) return say('Gefüllt, aber es müssen genau 3 S und 3 M pro Zeile/Spalte sein.', false);
                if (!rowsUnique(g) || !colsUnique(g)) return say('Gefüllt, aber doppelte Zeilen/Spalten.', false);
                return say(eq(g, tgSolution) ? 'Gelöst! ✅' : 'Regelkonformes Alternativ-Grid (nicht die Ziel-Lösung).', eq(g, tgSolution));
            }
            return say('Bisher konsistent. Weiter!', true);
        }

        /* Hint: eine logische Ableitung anwenden */
        function tgHint() {
            const cur = readGrid();
            const step = solveByLogic(cur);
            if (eq(step.grid, cur)) { say('Kein 1-Schritt-Hinweis gefunden.', false); return }
            // erste Differenz anwenden
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                if (cur[r][c] !== step.grid[r][c] && step.grid[r][c] != null) {
                    tgCells[r][c].textContent = step.grid[r][c];
                    tgCells[r][c].classList.add('flash'); setTimeout(() => tgCells[r][c].classList.remove('flash'), 180);
                    if (step.HNeq[r][c - 1] === '×') tgCells[r][c - 1]?.classList.add('neq-right');
                    if (step.VNeq[r - 1]?.[c] === '×') tgCells[r - 1]?.[c]?.classList.add('neq-down');
                    if (step.HEq[r][c - 1] === '=') tgCells[r][c - 1]?.classList.add('eq-right');
                    if (step.VEq[r - 1]?.[c] === '=') tgCells[r - 1]?.[c]?.classList.add('eq-down');
                    say('Logischen Schritt angewandt.', true);
                    return;
                }
            }
        }

        /* New: generiere Lösung -> carve mit Logik+Eindeutigkeit -> render */
        function tgNew() {
            tgMsg.classList.add('hidden');
            tgSolution = genSolved();
            const carved = carveFromSolution(tgSolution);
            tgGivens = carved.puzzle;
            renderBoard(tgGivens, carved.HEq, carved.VEq, carved.HNeq, carved.VNeq);
        }

        /* wire buttons */
        document.getElementById('tgNew').onclick = tgNew;
        document.getElementById('tgCheck').onclick = tgCheck;
        document.getElementById('tgHint').onclick = tgHint;

        /* boot */
        tgNew();
        /* ------------------- /TANGO ------------------- */













        // ---------- FUTOSHIKI 4×4 ----------
        const futoBoard = document.getElementById('futoBoard');
        const futoMsg = document.getElementById('futoMsg');
        const F = 4;
        const FUTO_PUZZLES = [
        {
            // givens: null or 1..4
            givens: [
            [null, 3,   null, null],
            [null, null, null, 1   ],
            [null, null, 2,    null],
            [4,    null, null, null]
            ],
            // right[r][c] is relation between (r,c) and (r,c+1): 'lt' or 'gt' (or null)
            right: [
            ['lt', null, null, null],
            [null, 'gt', null, null],
            [null, null, null, null],
            [null, null, 'lt', null],
            ],
            // down[r][c] between (r,c) and (r+1,c)
            down: [
            [null,'gt', null, null],
            [null, null,'lt', null],
            [null, null, null, null]
            ]
        },
        {
            givens: [
            [2,    null, null, null],
            [null, null, 3,    null],
            [null, 1,    null, null],
            [null, null, null, 4   ]
            ],
            right: [
            [null,'lt', null, null],
            [null, null,'gt', null],
            [null, null, null, null],
            [null, null, 'gt', null],
            ],
            down: [
            ['lt', null, null, null],
            [null, 'gt', null, null],
            [null, null, 'lt', null]
            ]
        }
        ];

        let futoCells=[], futoData=null;
        function futoRender(puz){
        futoBoard.innerHTML=''; futoCells=[]; futoData=puz;
        for(let r=0;r<F;r++){
            for(let c=0;c<F;c++){
            const d=document.createElement('div'); d.className='futo-cell'; d.dataset.r=r; d.dataset.c=c;
            const v=puz.givens[r][c]; if(v!=null){ d.textContent=String(v); d.dataset.lock='1'; } else { d.textContent=''; }
            // markers
            if(puz.right[r][c]==='lt') d.classList.add('lt-right'); else if(puz.right[r][c]==='gt') d.classList.add('gt-right');
            if(r<F-1){
                if(puz.down[r][c]==='lt') d.classList.add('lt-down'); else if(puz.down[r][c]==='gt') d.classList.add('gt-down');
            }
            d.onclick=()=>{ if(d.dataset.lock==='1') return; const cur=Number(d.textContent)||0; d.textContent = String(((cur)%4)+1); };
            futoBoard.appendChild(d);
            if(!futoCells[r]) futoCells[r]=[]; futoCells[r][c]=d;
            }
        }
        }
        function futoRead(){
        const g=[...Array(F)].map(()=>Array(F).fill(null));
        for(let r=0;r<F;r++) for(let c=0;c<F;c++){
            const t=futoCells[r][c].textContent.trim(); g[r][c]= t? Number(t): null;
        } return g;
        }
        function futoSay(msg,ok){ futoMsg.classList.remove('hidden'); futoMsg.innerHTML = `<span class="${ok?'ok':'bad'}">${msg}</span>` }
        function futoLatinOK(g){
        for(let i=0;i<F;i++){
            const row=g[i]; if(row.some(x=>x==null)) return false;
            const setR=new Set(row); if(setR.size!==F) return false;
            const col=[g[0][i],g[1][i],g[2][i],g[3][i]]; if(col.some(x=>x==null)) return false;
            const setC=new Set(col); if(setC.size!==F) return false;
        }
        return true;
        }
        function futoIneqOK(g,p){
        for(let r=0;r<F;r++) for(let c=0;c<F;c++){
            const a=g[r][c]; if(a==null) return false;
            if(c<F-1){
            const rel=p.right[r][c];
            if(rel){ const b=g[r][c+1]; if(b==null) return false; if(rel==='lt' && !(a<b)) return false; if(rel==='gt' && !(a>b)) return false; }
            }
            if(r<F-1){
            const rel2=p.down[r][c];
            if(rel2){ const b=g[r+1][c]; if(b==null) return false; if(rel2==='lt' && !(a<b)) return false; if(rel2==='gt' && !(a>b)) return false; }
            }
        }
        return true;
        }
        function futoCheck(){
        const g=futoRead();
        // allow partial: quick sanity warnings
        // 1) duplicates so far?
        for(let r=0;r<F;r++){
            const seen=new Set(); for(let c=0;c<F;c++){ const v=g[r][c]; if(v!=null){ if(seen.has(v)) return futoSay('Row duplicate detected.',false); seen.add(v); } }
        }
        for(let c=0;c<F;c++){
            const seen=new Set(); for(let r=0;r<F;r++){ const v=g[r][c]; if(v!=null){ if(seen.has(v)) return futoSay('Column duplicate detected.',false); seen.add(v); } }
        }
        // full check
        const full = g.every(row=>row.every(v=>v!=null));
        if(full){
            if(!futoLatinOK(g)) return futoSay('Must be 1–4 with no repeats per row/col.', false);
            if(!futoIneqOK(g,futoData)) return futoSay('Inequality violated.', false);
            STATE.best.futo = Math.max(1, STATE.best.futo||0); saveState(STATE);
            return futoSay('Solved! ✅', true);
        }
        return futoSay('Looks consistent so far.', true);
        }
        function futoNew(){
        futoMsg.classList.add('hidden');
        const puz = FUTO_PUZZLES[(Math.random()*FUTO_PUZZLES.length)|0];
        futoRender(puz);
        }
        document.getElementById('futoNew').onclick=futoNew;
        document.getElementById('futoCheck').onclick=futoCheck;
        futoNew();
        // ---------- /FUTOSHIKI ----------
    </script>
</body>

</html>