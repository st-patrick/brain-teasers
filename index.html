<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Brain Lab â€” Teasers & Training</title>
    <style>
        :root {
            --bg: #0b0d12;
            --card: #12151c;
            --fg: #e9edf5;
            --muted: #a5adbb;
            --acc: #7cc9ff;
            --ok: #6ee7a3;
            --bad: #ff7a7a;
            --warn: #ffd36b;
            --border: #1f2430;
        }

        * {
            box-sizing: border-box
        }

        body {
            margin: 0;
            font: 16px/1.5 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, sans-serif;
            background: radial-gradient(1200px 800px at 20% -10%, #142034 0%, #0b0d12 55%) fixed;
            color: var(--fg)
        }

        .wrap {
            max-width: 980px;
            margin: 0 auto;
            padding: 24px
        }

        header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            margin-bottom: 16px
        }

        h1 {
            font-size: 22px;
            margin: 0
        }

        .tabs {
            display: flex;
            gap: 8px;
            flex-wrap: wrap
        }

        .tab {
            border: 1px solid var(--border);
            background: linear-gradient(180deg, #181c25, #12151c);
            color: var(--fg);
            padding: 8px 12px;
            border-radius: 12px;
            cursor: pointer;
            user-select: none
        }

        .tab[aria-selected="true"] {
            outline: 2px solid var(--acc);
        }

        .card {
            background: linear-gradient(180deg, #151925, #10131b);
            border: 1px solid var(--border);
            box-shadow: 0 10px 30px rgba(0, 0, 0, .4);
            border-radius: 16px;
            padding: 18px;
            margin-top: 14px
        }

        .row {
            display: flex;
            gap: 12px;
            flex-wrap: wrap;
            align-items: center
        }

        button,
        .btn {
            background: #1a2030;
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 10px 14px;
            border-radius: 12px;
            cursor: pointer
        }

        button:hover {
            filter: brightness(1.08)
        }

        .btn-ghost {
            background: transparent;
            border-color: transparent;
            color: var(--muted)
        }

        .muted {
            color: var(--muted)
        }

        .big {
            font-size: 24px
        }

        .center {
            text-align: center
        }

        .grid {
            display: grid;
            gap: 12px
        }

        .two {
            grid-template-columns: repeat(2, minmax(0, 1fr))
        }

        .three {
            grid-template-columns: repeat(3, minmax(0, 1fr))
        }

        .four {
            grid-template-columns: repeat(4, minmax(0, 1fr))
        }

        input[type="text"],
        input[type="number"] {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0f1219;
            color: var(--fg)
        }

        .ok {
            color: var(--ok)
        }

        .bad {
            color: var(--bad)
        }

        .timer {
            font-variant-numeric: tabular-nums
        }

        .pill {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            border: 1px solid var(--border);
            background: #10131b;
            color: var(--muted);
            font-size: 12px
        }

        .hidden {
            display: none !important
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            background: #0c0f15;
            border: 1px solid var(--border);
            padding: 2px 6px;
            border-radius: 6px
        }

        .finish {
            padding: 10px;
            border: 1px dashed var(--border);
            background: #0e1220;
            border-radius: 12px
        }

        .flash {
            animation: flash .25s ease-out
        }

        @keyframes flash {
            from {
                transform: scale(1.04);
                text-shadow: 0 0 12px rgba(255, 255, 255, .08)
            }

            to {
                transform: scale(1);
                text-shadow: none
            }
        }

        @media (max-width:680px) {

            .two,
            .three,
            .four {
                grid-template-columns: 1fr
            }
        }

        /* Tango helpers */
        .board {
            display: grid;
            grid-template-columns: repeat(6, 40px);
            gap: 6px;
            justify-content: center
        }

        .cell {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: #0f1219;
            cursor: pointer;
            position: relative
        }

        .cell[data-lock="1"] {
            background: #141a25
        }

        .eq-right::after {
            content: '=';
            position: absolute;
            right: -10px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 12px;
            color: var(--muted)
        }

        .eq-down::before {
            content: '=';
            position: absolute;
            bottom: -12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: var(--muted)
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <h1>ðŸ§  Brain Lab</h1>
            <div class="tabs" role="tablist" aria-label="Modes">
                <div class="tab" role="tab" aria-selected="true" data-panel="teasers">Teasers</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="math">Speed Math</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="stroop">Stroop</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="nback">1-Back</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="nmem">Number Memory</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="read">Reading</div>
                <div class="tab" role="tab" aria-selected="false" data-panel="tango">Tango 6Ã—6</div>
            </div>
        </header>

        <!-- TEASERS -->
        <section id="teasers" class="card" role="tabpanel">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">LinkedInâ€‘style & classic logic â€¢ Solved <span id="teaserSolved">0</span>/<span
                            id="teaserTotal">0</span></div>
                    <h2 style="margin:6px 0 0">Brain Teaser</h2>
                </div>
                <div class="row">
                    <button id="newTeaser">New</button>
                    <button id="markSolved">Mark solved</button>
                    <button id="reveal">Reveal</button>
                </div>
            </div>
            <div style="height:8px"></div>
            <div id="teaserQ" class="big"></div>
            <details id="answerBox" class="card" style="margin-top:14px">
                <summary class="muted">Answer / Hint</summary>
                <div id="teaserA" style="margin-top:8px"></div>
            </details>
        </section>

        <!-- SPEED MATH -->
        <section id="math" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">30s arithmetic drill â€¢ High score <span id="mathBest">0</span></div>
                    <h2 style="margin:6px 0 0">Speed Math</h2>
                </div>
                <div class="row"><button id="mathStart">Start</button>
                    <div class="pill timer" id="mathTime">30</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div class="big" id="mathQ">Press Start</div>
                <div class="row center" style="justify-content:center;margin-top:10px">
                    <input id="mathInput" type="number" inputmode="numeric" placeholder="Answer"
                        style="max-width:220px" />
                    <button id="mathCheck">OK</button>
                </div>
                <div class="muted" style="margin-top:6px">Score: <span id="mathScore">0</span> â€¢ Streak <span
                        id="mathStreak">0</span> â€¢ <span id="mathFeedback"></span></div>
                <div id="mathFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- STROOP -->
        <section id="stroop" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Name the INK color â€¢ High score <span id="stroopBest">0</span></div>
                    <h2 style="margin:6px 0 0">Stroop Test</h2>
                </div>
                <div class="row"><button id="stroopStart">Start</button>
                    <div class="pill timer" id="stroopTime">30</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="stroopWord" class="big" style="font-weight:700;letter-spacing:.5px;">Press Start</div>
                <div id="stroopBtns" class="grid two" style="max-width:520px;margin:12px auto 0"></div>
                <div class="muted" style="margin-top:6px">Score: <span id="stroopScore">0</span> â€¢ Accuracy <span
                        id="stroopAcc">0%</span></div>
                <div id="stroopFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- 1-BACK -->
        <section id="nback" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Press when current == previous â€¢ High score <span id="nBest">0</span></div>
                    <h2 style="margin:6px 0 0">1â€‘Back Letters</h2>
                </div>
                <div class="row"><button id="nStart">Start</button>
                    <div class="pill timer" id="nTime">40</div>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="nIndex" class="muted" style="margin-bottom:4px">Seq: 0</div>
                <div id="nLetter" class="big" style="font-size:42px;font-weight:700">Press Start</div>
                <div class="row center" style="justify-content:center;margin-top:8px"><button id="nMatch">Match (<span
                            class="kbd">Space</span>)</button></div>
                <div class="muted" style="margin-top:6px">Score: <span id="nScore">0</span> â€¢ Hits <span
                        id="nHits">0</span> â€¢ False <span id="nFalse">0</span></div>
                <div id="nFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- NUMBER MEMORY -->
        <section id="nmem" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">Remember the number â€¢ High score <span id="nmBest">0</span></div>
                    <h2 style="margin:6px 0 0">Number Memory</h2>
                </div>
                <div class="row"><button id="nmStart">Start</button></div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="nmShow" class="big">Press Start</div>
                <div class="row center" style="justify-content:center;margin-top:10px">
                    <input id="nmInput" type="text" inputmode="numeric" placeholder="Type the number"
                        style="max-width:260px" />
                    <button id="nmCheck">OK</button>
                </div>
                <div class="muted" style="margin-top:6px">Level: <span id="nmLevel">0</span></div>
                <div id="nmFinish" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- READING COMPREHENSION -->
        <section id="read" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">One-word display â†’ tricky question â€¢ Best WPM <span id="rcBest">0</span></div>
                    <h2 style="margin:6px 0 0">Reading Comprehension</h2>
                </div>
                <div class="row">
                    <select id="rcTopic"></select>
                    <label class="pill">WPM <span id="rcWpm">240</span></label>
                    <input id="rcSpeed" type="range" min="120" max="700" step="10" value="240" style="width:160px" />
                    <button id="rcStart">Start</button>
                    <button id="rcPause">Pause</button>
                    <button id="rcReset">Reset</button>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="rcWord" class="big" style="min-height:40px">Pick a topic and Start</div>
                <div id="rcQA" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>

        <!-- TANGO 6x6 -->
        <section id="tango" class="card hidden" role="tabpanel" aria-hidden="true">
            <div class="row" style="justify-content:space-between">
                <div>
                    <div class="pill">6Ã—6 â€¢ 3 S & 3 M per row/col â€¢ no 3 in a row â€¢ '=' hints</div>
                    <h2 style="margin:6px 0 0">Tango</h2>
                </div>
                <div class="row">
                    <button id="tgNew">New</button>
                    <button id="tgHint">Hint</button>
                    <button id="tgCheck">Check</button>
                    <span class="pill">Legend: S=Sun, M=Moon</span>
                </div>
            </div>
            <div class="center" style="margin-top:10px">
                <div id="tgBoard" class="board"></div>
                <div id="tgMsg" class="finish hidden" style="margin-top:10px"></div>
            </div>
        </section>


        <p class="muted" style="margin-top:16px">Tip: Use <span class="kbd">Tab</span> to hop inputs. All games are
            offline, singleâ€‘file.</p>
    </div>

    <script>
        // ---------- STORAGE
        const STORE_KEY = 'brainlab_state_v2';
        function loadState() { try { return JSON.parse(localStorage.getItem(STORE_KEY)) || { best: { math: 0, stroop: 0, nback: 0, nmem: 0 }, solved: [] } } catch (e) { return { best: { math: 0, stroop: 0, nback: 0, nmem: 0 }, solved: [] } } }
        function saveState(s) { localStorage.setItem(STORE_KEY, JSON.stringify(s)) }
        let STATE = loadState();

        // ---------- TEASERS (expanded set)
        const TEASERS = [
            { q: "You have three labeled boxes: APPLES, ORANGES, MIXED. All labels are wrong. You may pick one fruit from one box. How do you relabel correctly?", a: "Pick one fruit from the MIXED box. Suppose you pull an apple. Then that box must be APPLES. The box labeled APPLES cannot be apples (labels are wrong) and cannot be mixed, so it must be ORANGES. The remaining box is MIXED." },
            { q: "Two trains start 120 km apart and head toward each other, each at 60 km/h. A bee flies back and forth between them at 90 km/h until the trains meet. Total distance flown?", a: "Time to meet = 120/(60+60)=1 hour. Bee flies 90 km." },
            { q: "A 5â€‘letter code word uses letters A, B, C, D, E exactly once. The third letter is a vowel; B is left of D; A is not adjacent to E. Give one valid word.", a: "One example: B A E C D." },
            { q: "You see 5 hats: 3 black, 2 white. Three people wear one hat each. In order they say: 'I don't know.' 'I don't know.' Third says 'I know.' What color is the third hat?", a: "Black, by elimination: if two whites were visible the first would know immediately. This propagates to the third." },
            { q: "You have 7â€‘ and 11â€‘minute hourglasses. Measure exactly 15 minutes.", a: "Start both. At 7: flip 7. At 11: flip 11 (7 has 3 left). When 7 empties (14): flip 11; after 1 minute = 15." },
            { q: "A number is divisible by 3, ends with 5, and digit sum is 12. What is it?", a: "75." },
            { q: "Five sit round a table. Alex between Bea and Cam. Dan not next to Alex. Eve sits two seats clockwise from Bea. Who sits between Dan and Eve?", a: "Cam, in one valid arrangement: Bea, Alex, Cam, Dan, Eve." },
            { q: "You drop a 1Ã—1Ã—1 cube into a bucket, fill to brim, then remove cube. Overflow, same, or drop?", a: "Drop. Removing cube removes displaced volume." },
            { q: "Pick a prime between 51 and 100 that is one less than a multiple of 6.", a: "Any of 53,59,71,83,89." },
            { q: "Smallest positive integer that leaves remainders 1,2,3 when divided by 2,3,4 respectively?", a: "11 (it's âˆ’1 mod lcm(2,3,4)=12)." },
            // new verbal riddles
            { q: "A man looks at a painting and says, 'Brothers and sisters, I have none, but that man's father is my father's son.' Who is in the painting?", a: "His son." },
            { q: "What 3â€‘letter word completes all: _IGHT (8), _EAD (lead), _ORE (ore) and becomes a new valid word each time?", a: "'L' â†’ LIGHT, LEAD, LORE." },
            { q: "You buy a $10 item. You overpay with a $20 and receive $10 and the item. Later the cashier realizes the $20 was counterfeit and pays the store $20 from their own wallet. Total loss to the cashier?", a: "$20 (they lost a real $20 and the store lost nothing net)." },
            { q: "You have two ropes. Each burns in exactly 60 minutes but not at a consistent rate. How to measure 45 minutes?", a: "Light Rope A at both ends and Rope B at one end. When A finishes (30 min), light the other end of B (15 more) â†’ 45." },
            { q: "Which weighs more: a kilo of feathers or a kilo of steel?", a: "Same mass; volume differs." },
            { q: "You meet two guards: one always lies, one always tells truth. One door leads to freedom. One question to ask one guard?", a: "Ask either: 'Which door would the other say is freedom?' Then go the other way." },
            { q: "A farmer needs to take a fox, a chicken, and grain across a river with a boat that holds one item at a time. How?", a: "Take chicken; return; take fox; bring chicken back; take grain; return; take chicken." },
            { q: "You have 8 balls, one is heavier, balance scale, find in 2 weighings. How?", a: "Weigh 3 vs 3. If equal, heavier is among remaining 2 â†’ weigh 1 vs 1. Else take heavier group of 3 and weigh 1 vs 1, using logic to find the heavier." },
            { q: "A clock shows 3:15. What is the angle between hour and minute hands?", a: "At 3:15, minute at 90Â°. Hour hand at 97.5Â°. Angle 7.5Â°." }
        ];
        let idx = 0; const qEl = document.getElementById('teaserQ'); const aEl = document.getElementById('teaserA');
        const solvedEl = document.getElementById('teaserSolved'); const totalEl = document.getElementById('teaserTotal'); totalEl.textContent = TEASERS.length;
        function refreshSolved() { solvedEl.textContent = STATE.solved.length }
        function showTeaser(i) { const t = TEASERS[i % TEASERS.length]; qEl.textContent = t.q; aEl.textContent = t.a; document.getElementById('answerBox').open = false }
        showTeaser(idx); refreshSolved();

        document.getElementById('newTeaser').onclick = () => { idx = (idx + 1) % TEASERS.length; showTeaser(idx) };
        document.getElementById('reveal').onclick = () => { document.getElementById('answerBox').open = true }
        document.getElementById('markSolved').onclick = () => { if (!STATE.solved.includes(idx)) { STATE.solved.push(idx); saveState(STATE); refreshSolved(); } }

        // ---------- TABS
        const tabs = [...document.querySelectorAll('.tab')];
        tabs.forEach(t => t.addEventListener('click', () => {
            tabs.forEach(x => x.setAttribute('aria-selected', 'false'));
            t.setAttribute('aria-selected', 'true');
            const panel = t.dataset.panel;[...document.querySelectorAll('section[role="tabpanel"]')].forEach(sec => {
                const on = sec.id === panel; sec.classList.toggle('hidden', !on); sec.setAttribute('aria-hidden', (!on).toString());
            })
        }))

        // helpers
        function randInt(a, b) { return Math.floor(Math.random() * (b - a + 1)) + a }

        // ---------- SPEED MATH
        const mathQ = document.getElementById('mathQ');
        const mathInput = document.getElementById('mathInput');
        const mathScoreEl = document.getElementById('mathScore');
        const mathStreakEl = document.getElementById('mathStreak');
        const mathFeedback = document.getElementById('mathFeedback');
        const mathTime = document.getElementById('mathTime');
        const mathBest = document.getElementById('mathBest'); mathBest.textContent = STATE.best.math;
        const mathFinish = document.getElementById('mathFinish');
        let mathTimer = null, mathLeft = 30, mathScore = 0, mathStreak = 0, truth = 0;
        function newMathQ() {
            const ops = ['+', '-', 'Ã—', 'Ã·'];
            const op = ops[randInt(0, ops.length - 1)];
            let a = randInt(2, 25), b = randInt(2, 25);
            if (op === 'Ã·') { truth = a; const prod = a * b; mathQ.textContent = `${prod} Ã· ${b}` }
            else if (op === 'Ã—') { truth = a * b; mathQ.textContent = `${a} Ã— ${b}` }
            else if (op === '+') { truth = a + b; mathQ.textContent = `${a} + ${b}` }
            else { if (a < b) [a, b] = [b, a]; truth = a - b; mathQ.textContent = `${a} âˆ’ ${b}` }
            mathQ.classList.add('flash'); setTimeout(() => mathQ.classList.remove('flash'), 180);
        }
        function endMath() {
            clearInterval(mathTimer); mathTimer = null; mathFeedback.textContent = '';
            const prevBest = STATE.best.math || 0; if (mathScore > prevBest) { STATE.best.math = mathScore; saveState(STATE); mathBest.textContent = STATE.best.math; }
            mathFinish.classList.remove('hidden');
            mathFinish.innerHTML = `Finished! Score <b>${mathScore}</b> â€¢ Best <b>${STATE.best.math}</b> <div style="margin-top:6px"><button onclick="(${startMath.toString()})()">Play again</button></div>`;
            mathQ.textContent = 'Done';
        }
        function startMath() {
            mathFinish.classList.add('hidden');
            mathLeft = 30; mathScore = 0; mathStreak = 0; mathScoreEl.textContent = '0'; mathStreakEl.textContent = '0'; mathTime.textContent = '30'; newMathQ(); mathInput.value = ''; mathInput.focus();
            if (mathTimer) clearInterval(mathTimer);
            mathTimer = setInterval(() => { mathLeft--; mathTime.textContent = String(mathLeft); if (mathLeft <= 0) { endMath() } }, 1000);
        }
        function checkMath() {
            const val = Number(mathInput.value);
            if (Number.isFinite(val) && val === truth) { mathScore++; mathStreak++; mathFeedback.textContent = 'âœ”'; mathFeedback.className = 'ok'; newMathQ() } else { mathStreak = 0; mathFeedback.textContent = 'âœ–'; mathFeedback.className = 'bad' }
            mathScoreEl.textContent = String(mathScore); mathStreakEl.textContent = String(mathStreak); mathInput.value = ''; mathInput.focus()
        }

        document.getElementById('mathStart').onclick = startMath;
        document.getElementById('mathCheck').onclick = checkMath;
        mathInput.addEventListener('keydown', e => { if (e.key === 'Enter') checkMath() });

        // ---------- STROOP
        const COLORS = [
            { name: 'RED', css: '#ef4444' },
            { name: 'BLUE', css: '#3b82f6' },
            { name: 'GREEN', css: '#22c55e' },
            { name: 'YELLOW', css: '#eab308' },
            { name: 'PURPLE', css: '#a855f7' }
        ];
        const stroopWord = document.getElementById('stroopWord');
        const stroopBtns = document.getElementById('stroopBtns');
        const stroopScoreEl = document.getElementById('stroopScore');
        const stroopAccEl = document.getElementById('stroopAcc');
        const stroopTime = document.getElementById('stroopTime');
        const stroopBest = document.getElementById('stroopBest'); stroopBest.textContent = STATE.best.stroop;
        const stroopFinish = document.getElementById('stroopFinish');
        let stroopTimer = null, stroopLeft = 30, stroopScore = 0, stroopTries = 0, stroopAnswer = '';
        function setupStroopButtons() { stroopBtns.innerHTML = ''; COLORS.forEach(c => { const b = document.createElement('button'); b.textContent = c.name; b.style.borderColor = c.css; b.onclick = () => pickStroop(c.name); stroopBtns.appendChild(b) }) }
        function newStroop() { const word = COLORS[Math.floor(Math.random() * COLORS.length)].name; const ink = COLORS[Math.floor(Math.random() * COLORS.length)]; stroopAnswer = ink.name; stroopWord.textContent = word; stroopWord.style.color = ink.css; stroopWord.classList.add('flash'); setTimeout(() => stroopWord.classList.remove('flash'), 180) }
        function pickStroop(name) { if (!stroopTimer) return; stroopTries++; if (name === stroopAnswer) stroopScore++; stroopScoreEl.textContent = String(stroopScore); stroopAccEl.textContent = `${Math.round(100 * (stroopTries ? stroopScore / stroopTries : 0))}%`; newStroop() }
        function endStroop() {
            clearInterval(stroopTimer); stroopTimer = null;
            const prevBest = STATE.best.stroop || 0; if (stroopScore > prevBest) { STATE.best.stroop = stroopScore; saveState(STATE); stroopBest.textContent = STATE.best.stroop; }
            stroopFinish.classList.remove('hidden');
            stroopFinish.innerHTML = `Finished! Score <b>${stroopScore}</b> â€¢ Acc <b>${Math.round(100 * (stroopTries ? stroopScore / stroopTries : 0))}%</b> â€¢ Best <b>${STATE.best.stroop}</b> <div style="margin-top:6px"><button onclick="(${startStroop.toString()})()">Play again</button></div>`;
            stroopWord.textContent = 'Done';
        }
        function startStroop() {
            stroopFinish.classList.add('hidden');
            stroopLeft = 30; stroopScore = 0; stroopTries = 0; stroopScoreEl.textContent = '0'; stroopAccEl.textContent = '0%'; stroopTime.textContent = '30'; newStroop(); if (stroopTimer) clearInterval(stroopTimer); stroopTimer = setInterval(() => { stroopLeft--; stroopTime.textContent = String(stroopLeft); if (stroopLeft <= 0) endStroop() }, 1000)
        }
        setupStroopButtons();
        document.getElementById('stroopStart').onclick = startStroop;

        // ---------- 1-BACK
        const LETTERS = 'ABCDEFGHJKLMNPQRSTUVWXZ'.split(''); // avoid I/O/Y/0
        const nLetter = document.getElementById('nLetter');
        const nTime = document.getElementById('nTime');
        const nScoreEl = document.getElementById('nScore');
        const nHits = document.getElementById('nHits');
        const nFalse = document.getElementById('nFalse');
        const nBest = document.getElementById('nBest'); nBest.textContent = STATE.best.nback;
        const nFinish = document.getElementById('nFinish');
        const nIndex = document.getElementById('nIndex');

        let nTimer = null, seq = [], targetPos = new Set(), seqIdx = 0, allow = false;
        let nScore = 0, nHit = 0, nFalseC = 0, totalTargets = 0;

        function makeNBackSequence(len = 30, targets = 8) {
            const s = new Array(len);
            targetPos = new Set();

            // choose target indices from 1..len-1 (positions that can repeat previous)
            const pool = [...Array(len - 1).keys()].map(i => i + 1);
            for (let i = pool.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[pool[i], pool[j]] = [pool[j], pool[i]]; }
            const picks = new Set(pool.slice(0, targets));

            s[0] = LETTERS[Math.floor(Math.random() * LETTERS.length)];
            for (let i = 1; i < len; i++) {
                if (picks.has(i)) { s[i] = s[i - 1]; targetPos.add(i); }
                else {
                    let c; do { c = LETTERS[Math.floor(Math.random() * LETTERS.length)] } while (c === s[i - 1]);
                    s[i] = c;
                }
            }
            totalTargets = targetPos.size; // safety
            return s;
        }

        function stepN() {
            if (seqIdx >= seq.length) { endN(); return; }
            nIndex.textContent = `Seq: ${seqIdx + 1} / ${seq.length} â€¢ Targets this run: ${totalTargets}`;
            nLetter.textContent = seq[seqIdx];
            nLetter.classList.add('flash'); setTimeout(() => nLetter.classList.remove('flash'), 180);
            allow = true;
            nTime.textContent = String(seq.length - seqIdx - 1); // seconds left (1 item/sec)
            seqIdx++;
        }

        function pressMatch() {
            if (!nTimer || !allow) return;
            const isTarget = targetPos.has(seqIdx - 1); // current item index is seqIdx-1
            if (isTarget) { nScore++; nHit++; } else { nScore = Math.max(0, nScore - 1); nFalseC++; }
            nScoreEl.textContent = String(nScore);
            nHits.textContent = String(nHit);
            nFalse.textContent = String(nFalseC);
            allow = false;
        }

        function endN() {
            clearInterval(nTimer); nTimer = null; allow = false;
            const misses = Math.max(0, totalTargets - nHit);
            if (nHit > (STATE.best.nback || 0)) { STATE.best.nback = nHit; saveState(STATE); nBest.textContent = STATE.best.nback; }
            nFinish.classList.remove('hidden');
            nFinish.innerHTML = `Finished! Hits <b>${nHit}</b> / ${totalTargets} â€¢ Missed <b>${misses}</b> â€¢ False <b>${nFalseC}</b> â€¢ Best hits <b>${STATE.best.nback}</b>
    <div style="margin-top:6px"><button onclick="(${startN.toString()})()">Play again</button></div>`;
            nLetter.textContent = 'Done';
        }

        function startN() {
            nFinish.classList.add('hidden');
            // Comparable: fixed length & target count. Double speed: 1 item/sec.
            seq = makeNBackSequence(30, 8); // 30 items, exactly 8 targets
            seqIdx = 0; nScore = 0; nHit = 0; nFalseC = 0; allow = false;
            nScoreEl.textContent = '0'; nHits.textContent = '0'; nFalse.textContent = '0';
            if (nTimer) clearInterval(nTimer);
            stepN();                                // first immediately
            nTimer = setInterval(stepN, 1000);      // then every 1s
        }

        document.getElementById('nStart').onclick = startN;
        document.getElementById('nMatch').onclick = pressMatch;
        window.addEventListener('keydown', e => { if (e.code === 'Space') { e.preventDefault(); pressMatch(); } });


        // ---------- NUMBER MEMORY
        const nmShow = document.getElementById('nmShow');
        const nmInput = document.getElementById('nmInput');
        const nmLevelEl = document.getElementById('nmLevel');
        const nmBestEl = document.getElementById('nmBest'); nmBestEl.textContent = STATE.best.nmem;
        const nmFinish = document.getElementById('nmFinish');
        let nmLevel = 0, nmCurrent = '';
        function randDigits(n) { let s = ''; for (let i = 0; i < n; i++) s += String(Math.floor(Math.random() * 10)); return s }
        function nmStart() { nmFinish.classList.add('hidden'); nmLevel = 1; nmLevelEl.textContent = '1'; nmNext() }
        function nmNext() { nmCurrent = randDigits(nmLevel); nmShow.textContent = nmCurrent; nmShow.classList.add('flash'); setTimeout(() => { nmShow.textContent = 'â€¦'; }, 900); nmInput.value = ''; nmInput.focus() }
        function nmCheck() {
            const ok = nmInput.value.trim() === nmCurrent; if (ok) { nmLevel++; nmLevelEl.textContent = String(nmLevel); nmNext() } else { const bestPrev = STATE.best.nmem || 0; const achieved = Math.max(1, nmLevel - 1); if (achieved > bestPrev) { STATE.best.nmem = achieved; saveState(STATE); nmBestEl.textContent = STATE.best.nmem } nmFinish.classList.remove('hidden'); nmFinish.innerHTML = `Finished! Level reached <b>${achieved}</b> â€¢ Best <b>${STATE.best.nmem}</b> <div style="margin-top:6px"><button onclick="(${nmStart.toString()})()">Play again</button></div>`; nmShow.textContent = 'Done' }
        }

        document.getElementById('nmStart').onclick = nmStart;
        document.getElementById('nmCheck').onclick = nmCheck;
        nmInput.addEventListener('keydown', e => { if (e.key === 'Enter') nmCheck() });


        // ---------- READING COMPREHENSION
        if (!STATE.best.rc) STATE.best.rc = {};

        const RC_TOPICS = [
            {
                topic: 'Coffee trade',
                text: "Brazil exported roasted coffee to Italy after a drought eased, while Italy reduced shipments back to Brazil, focusing instead on espresso machine sales to France.",
                q: "Based on the passage, which direction was the coffee moving?",
                choices: ["Italy â†’ Brazil", "Brazil â†’ Italy", "France â†’ Brazil"], answer: 1
            },
            {
                topic: 'Space probes',
                text: "Pioneer 10 launched before Voyager 2, but only Voyager carried the Golden Record. Both probes flew past giant planets; Voyager took the famous portrait of the Solar System.",
                q: "Which probe launched first?",
                choices: ["Voyager 2", "Pioneer 10", "Both together"], answer: 1
            },
            {
                topic: 'Rivers & cities',
                text: "The Arlen River flows north into the Calder. City X lies upstream of City Y on the Arlen, yet south of the Calder delta.",
                q: "Relative to City Y, where is City X on the Arlen?",
                choices: ["Downstream", "Upstream", "Same location"], answer: 1
            },
            {
                topic: 'History note',
                text: "In 1867, Country A ceded its northern territory to Country B. Decades later, A imported timber from B while exporting coal to C.",
                q: "Who ceded territory to whom?",
                choices: ["B â†’ A", "A â†’ B", "C â†’ A"], answer: 1
            }
        ];

        const rcTopicSel = document.getElementById('rcTopic');
        const rcWord = document.getElementById('rcWord');
        const rcQA = document.getElementById('rcQA');
        const rcBestEl = document.getElementById('rcBest');
        const rcSpeed = document.getElementById('rcSpeed');
        const rcWpm = document.getElementById('rcWpm');
        const rcStart = document.getElementById('rcStart');
        const rcPause = document.getElementById('rcPause');
        const rcReset = document.getElementById('rcReset');

        let rcTimer = null, rcIdx = 0, rcWords = [], rcPaused = false;

        function rcFillTopics() {
            rcTopicSel.innerHTML = '';
            RC_TOPICS.forEach((t, i) => {
                const o = document.createElement('option');
                o.value = String(i); o.textContent = t.topic;
                rcTopicSel.appendChild(o);
            });
            rcUpdateBest();
        }
        function rcUpdateBest() {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            const best = (STATE.best.rc[t.topic] || 0);
            rcBestEl.textContent = best;
        }
        function rcShowNext() {
            if (rcIdx >= rcWords.length) {
                clearInterval(rcTimer); rcTimer = null;
                rcAsk(); return;
            }
            rcWord.textContent = rcWords[rcIdx++];
            rcWord.classList.add('flash'); setTimeout(() => rcWord.classList.remove('flash'), 150);
        }
        function rcStartRun() {
            rcQA.classList.add('hidden'); rcQA.innerHTML = '';
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            rcWords = t.text.split(/\s+/);
            rcIdx = 0; rcShowNext(); rcPaused = false;
            if (rcTimer) clearInterval(rcTimer);
            const ms = Math.max(60, Math.round(60000 / Number(rcSpeed.value))); // speedable
            rcTimer = setInterval(rcShowNext, ms);
        }
        function rcPauseRun() {
            if (!rcTimer) { return }
            clearInterval(rcTimer); rcTimer = null; rcPaused = true;
            rcWord.textContent += ' â–Œ';
        }
        function rcResetRun() {
            if (rcTimer) { clearInterval(rcTimer); rcTimer = null }
            rcWord.textContent = 'Pick a topic and Start';
            rcQA.classList.add('hidden');
        }
        function rcAsk() {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            rcWord.textContent = '?';
            rcQA.classList.remove('hidden');
            const wrap = document.createElement('div');
            wrap.innerHTML = `<div><b>${t.q}</b></div>`;
            t.choices.forEach((c, i) => {
                const b = document.createElement('button');
                b.textContent = c; b.style.margin = '6px';
                b.onclick = () => rcAnswer(i);
                wrap.appendChild(b);
            });
            rcQA.innerHTML = ''; rcQA.appendChild(wrap);
        }
        function rcAnswer(i) {
            const t = RC_TOPICS[Number(rcTopicSel.value || 0)];
            const correct = i === t.answer;
            rcQA.innerHTML = `You are <b class="${correct ? 'ok' : 'bad'}">${correct ? 'correct' : 'wrong'}</b>.` + (correct ? ' Nice.' : '');
            if (correct) {
                const wpm = Number(rcSpeed.value);
                const best = STATE.best.rc[t.topic] || 0;
                if (wpm > best) { STATE.best.rc[t.topic] = wpm; saveState(STATE); rcBestEl.textContent = wpm }
            }
        }
        rcSpeed.oninput = () => { rcWpm.textContent = rcSpeed.value; if (rcTimer) { clearInterval(rcTimer); const ms = Math.max(60, Math.round(60000 / Number(rcSpeed.value))); rcTimer = setInterval(rcShowNext, ms) } };
        rcStart.onclick = rcStartRun; rcPause.onclick = rcPauseRun; rcReset.onclick = rcResetRun; rcTopicSel.onchange = rcUpdateBest;
        rcFillTopics();


        /* ------------------- TANGO (Takuzu 6Ã—6) ------------------- */
        /* Symbols */
        const TG = 6, S = 'S', M = 'M';
        const tgBoard = document.getElementById('tgBoard'), tgMsg = document.getElementById('tgMsg');
        let tgCells = [], tgHEq = [], tgVEq = [], tgHNeq = [], tgVNeq = [], tgSolution = [], tgGivens = [];

        /* -------- utils -------- */
        const rng = () => Math.random();
        function shuffle(a) { for (let i = a.length - 1; i > 0; i--) { const j = (rng() * (i + 1)) | 0;[a[i], a[j]] = [a[j], a[i]] } return a }
        function empty() { return Array.from({ length: TG }, () => Array(TG).fill(null)) }
        function clone(g) { return g.map(r => r.slice()) }
        function isFull(g) { return g.every(r => r.every(v => v != null)) }
        function rowCount(g, r, v) { return g[r].filter(x => x === v).length }
        function colCount(g, c, v) { let n = 0; for (let r = 0; r < TG; r++) if (g[r][c] === v) n++; return n }
        function eq(a, b) { return JSON.stringify(a) === JSON.stringify(b) }

        /* hard/soft constraints */
        function noTriples(g) {
            // returns true if any illegal triple exists
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG - 2; c++) {
                const a = g[r][c], b = g[r][c + 1], d = g[r][c + 2];
                if (a && a === b && b === d) return true;
            }
            for (let c = 0; c < TG; c++) for (let r = 0; r < TG - 2; r++) {
                const a = g[r][c], b = g[r + 1][c], d = g[r + 2][c];
                if (a && a === b && b === d) return true;
            }
            return false;
        }
        function countsOK(g) {
            for (let r = 0; r < TG; r++) {
                const s = rowCount(g, r, S), m = rowCount(g, r, M);
                if (s > 3 || m > 3) return false;
            }
            for (let c = 0; c < TG; c++) {
                let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (g[r][c] === S) s++; else if (g[r][c] === M) m++; }
                if (s > 3 || m > 3) return false;
            }
            return true;
        }
        function countsExact(g) {
            for (let r = 0; r < TG; r++) if (rowCount(g, r, S) !== 3 || rowCount(g, r, M) !== 3) return false;
            for (let c = 0; c < TG; c++) {
                let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (g[r][c] === S) s++; else if (g[r][c] === M) m++; }
                if (s !== 3 || m !== 3) return false;
            }
            return true;
        }
        function rowsUnique(g) {
            for (let i = 0; i < TG; i++) for (let j = i + 1; j < TG; j++) {
                let comp = true;
                for (let k = 0; k < TG; k++) { const a = g[i][k], b = g[j][k]; if (a == null || b == null || a !== b) { comp = false; break } }
                if (comp) return false;
            } return true;
        }
        function colsUnique(g) {
            for (let i = 0; i < TG; i++) for (let j = i + 1; j < TG; j++) {
                let comp = true;
                for (let r = 0; r < TG; r++) { const a = g[r][i], b = g[r][j]; if (a == null || b == null || a !== b) { comp = false; break } }
                if (comp) return false;
            } return true;
        }
        function legalLocal(g, r, c) {
            if (!countsOK(g)) return false;
            // local triple checks around (r,c)
            for (let k = c - 2; k <= c; k++) {
                if (k < 0 || k + 2 >= TG) continue;
                const a = g[r][k], b = g[r][k + 1], d = g[r][k + 2];
                if (a && b && d && a === b && b === d) return false;
            }
            for (let k = r - 2; k <= r; k++) {
                if (k < 0 || k + 2 >= TG) continue;
                const a = g[k][c], b = g[k + 1][c], d = g[k + 2][c];
                if (a && b && d && a === b && b === d) return false;
            }
            // if row full -> exact + unique vs other full rows
            if (g[r].every(x => x != null)) {
                if (rowCount(g, r, S) !== 3 || rowCount(g, r, M) !== 3) return false;
                for (let rr = 0; rr < TG; rr++) if (rr !== r && g[rr].every(x => x != null)) {
                    if (g[rr].every((x, k) => x === g[r][k])) return false;
                }
            }
            // if column full -> exact + unique vs other full cols
            let cFull = true; for (let rr = 0; rr < TG; rr++) if (g[rr][c] == null) { cFull = false; break }
            if (cFull) {
                let s = 0, m = 0; for (let rr = 0; rr < TG; rr++) { if (g[rr][c] === S) s++; else if (g[rr][c] === M) m++; }
                if (s !== 3 || m !== 3) return false;
                for (let cc = 0; cc < TG; cc++) if (cc !== c) {
                    let otherFull = true, same = true;
                    for (let rr = 0; rr < TG; rr++) { if (g[rr][cc] == null) { otherFull = false; break } }
                    if (otherFull) { for (let rr = 0; rr < TG; rr++) { if (g[rr][cc] !== g[rr][c]) { same = false; break } } if (same) return false; }
                }
            }
            return true;
        }

        /* -------- generator: random solved board (backtracking + randomized order) -------- */
        function genSolved() {
            const g = empty();
            const coords = []; for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) coords.push([r, c]);
            shuffle(coords);
            function back(i) {
                if (i === coords.length) { return !noTriples(g) && countsExact(g) && rowsUnique(g) && colsUnique(g) }
                const [r, c] = coords[i];
                const vals = rng() < 0.5 ? [S, M] : [M, S];
                for (const v of vals) {
                    g[r][c] = v;
                    if (legalLocal(g, r, c) && back(i + 1)) return true;
                }
                g[r][c] = null; return false;
            }
            if (!back(0)) return genSolved(); // extremely selten
            return g;
        }

        /* -------- logic solver (deterministic Takuzu steps for hints & carving) --------
           Regeln: (1) keine 3 in Folge -> XX_ -> XXO; X_X -> O; (2) Zeilen/Spalten auffÃ¼llen wenn 3 erreicht;
           (3) Gegen identische vollendete Zeilen/Spalten: offene Felder mÃ¼ssen GegensÃ¤tze sein. */
        function solveByLogic(g) {
            const grid = clone(g);
            const HEq = empty(), VEq = empty(), HNeq = empty(), VNeq = empty(); // overlays (= / Ã—)
            let changed = true, guard = 0;
            function setCell(r, c, val, mark) {
                if (grid[r][c] == null) {
                    grid[r][c] = val;
                    if (mark) {
                        if (mark.hneq != null) HNeq[r][mark.hneq] = 'Ã—';
                        if (mark.vneq != null) VNeq[mark.vneq][c] = 'Ã—';
                        if (mark.heq != null) HEq[r][mark.heq] = '=';
                        if (mark.veq != null) VEq[mark.veq][c] = '=';
                    }
                }
            }
            while (changed && guard++ < 600) {
                changed = false;

                // A) Triples verhindern â€“ Reihen
                for (let r = 0; r < TG; r++) for (let c = 0; c < TG - 2; c++) {
                    const a = grid[r][c], b = grid[r][c + 1], d = grid[r][c + 2];
                    if (a != null && b != null && d == null && a === b) { setCell(r, c + 2, a === S ? M : S, { hneq: c + 1 }); changed = true }
                    if (a == null && b != null && d != null && b === d) { setCell(r, c, b === S ? M : S, { hneq: c }); changed = true }
                    if (a != null && b == null && d != null && a === d) { setCell(r, c + 1, a === S ? M : S, { hneq: c + 1 }); changed = true }
                }
                // A) Triples verhindern â€“ Spalten
                for (let c = 0; c < TG; c++) for (let r = 0; r < TG - 2; r++) {
                    const a = grid[r][c], b = grid[r + 1][c], d = grid[r + 2][c];
                    if (a != null && b != null && d == null && a === b) { setCell(r + 2, c, a === S ? M : S, { vneq: r + 1 }); changed = true }
                    if (a == null && b != null && d != null && b === d) { setCell(r, c, b === S ? M : S, { vneq: r }); changed = true }
                    if (a != null && b == null && d != null && a === d) { setCell(r + 1, c, a === S ? M : S, { vneq: r + 1 }); changed = true }
                }

                // B) 3 pro Zeile/Spalte erzwingen
                for (let r = 0; r < TG; r++) {
                    const s = rowCount(grid, r, S), m = rowCount(grid, r, M);
                    if (s === 3) { for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, M); changed = true } }
                    if (m === 3) { for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, S); changed = true } }
                }
                for (let c = 0; c < TG; c++) {
                    let s = 0, m = 0; for (let r = 0; r < TG; r++) { if (grid[r][c] === S) s++; else if (grid[r][c] === M) m++; }
                    if (s === 3) { for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, M); changed = true } }
                    if (m === 3) { for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, S); changed = true } }
                }

                // C) Gegen identische fertige Zeilen/Spalten absichern
                // Zeilen
                for (let r = 0; r < TG; r++) {
                    if (grid[r].every(x => x != null)) continue;
                    for (let rr = 0; rr < TG; rr++) {
                        if (rr === r) continue;
                        if (!grid[rr].every(x => x != null)) continue; // nur gegen fertige vergleichen
                        let compatible = true;
                        for (let c = 0; c < TG; c++) { if (grid[r][c] != null && grid[r][c] !== grid[rr][c]) { compatible = false; break } }
                        if (compatible) {
                            for (let c = 0; c < TG; c++) if (grid[r][c] == null) { setCell(r, c, grid[rr][c] === S ? M : S, {}); changed = true }
                        }
                    }
                }
                // Spalten
                for (let c = 0; c < TG; c++) {
                    let colFull = true; for (let r = 0; r < TG; r++) if (grid[r][c] == null) { colFull = false; break }
                    if (colFull) continue;
                    for (let cc = 0; cc < TG; cc++) {
                        if (cc === c) continue;
                        let otherFull = true; for (let r = 0; r < TG; r++) if (grid[r][cc] == null) { otherFull = false; break }
                        if (!otherFull) continue;
                        let compatible = true;
                        for (let r = 0; r < TG; r++) { const a = grid[r][c], b = grid[r][cc]; if (a != null && b != null && a !== b) { compatible = false; break } }
                        if (compatible) {
                            for (let r = 0; r < TG; r++) if (grid[r][c] == null) { setCell(r, c, grid[r][cc] === S ? M : S, {}); changed = true }
                        }
                    }
                }
            }
            const solved = isFull(grid) && !noTriples(grid) && countsExact(grid) && rowsUnique(grid) && colsUnique(grid);
            return { grid, HEq, VEq, HNeq, VNeq, solved };
        }

        /* -------- full solver (backtracking) to check uniqueness -------- */
        function firstEmpty(g) {
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) if (g[r][c] == null) return [r, c];
            return null;
        }
        function tryValuesRandom() { return rng() < 0.5 ? [S, M] : [M, S]; }
        function solveBacktrack(grid, stopAt = 1) {
            let count = 0, last = null;
            const g = clone(grid);
            function dfs() {
                if (noTriples(g) || !countsOK(g)) return;
                // simple forward: if any row/col full, check exact+unique against existing full ones
                // (already partly covered in legalLocal when placing, but we pick empties directly here)
                const e = firstEmpty(g);
                if (!e) {
                    if (countsExact(g) && rowsUnique(g) && colsUnique(g)) { count++; last = clone(g); }
                    return;
                }
                const [r, c] = e, vals = tryValuesRandom();
                for (const v of vals) {
                    g[r][c] = v;
                    if (legalLocal(g, r, c)) {
                        dfs();
                        if (count >= stopAt) { g[r][c] = null; return; }
                    }
                    g[r][c] = null;
                }
            }
            dfs();
            return { count, solution: last };
        }

        /* -------- Carving: entferne nur Felder, die logisch herleitbar sind UND die Eindeutigkeit erhalten -------- */
        function carveFromSolution(sol) {
            let puzzle = clone(sol);
            const cells = []; for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) cells.push([r, c]);
            shuffle(cells);

            let bestHEq = empty(), bestVEq = empty(), bestHNeq = empty(), bestVNeq = empty();

            for (const [r, c] of cells) {
                const keep = puzzle[r][c]; puzzle[r][c] = null;

                // 1) mit Logik auflÃ¶sen
                const step = solveByLogic(puzzle);
                // 2) wenn Logik vollstÃ¤ndig zur selben LÃ¶sung fÃ¼hrt UND eindeutig bleibt, behalten
                if (step.solved && eq(step.grid, sol)) {
                    const uniq = solveBacktrack(puzzle, 2);
                    if (uniq.count === 1) {
                        bestHEq = step.HEq; bestVEq = step.VEq; bestHNeq = step.HNeq; bestVNeq = step.VNeq;
                        continue; // Entfernung akzeptiert
                    }
                }
                // sonst rÃ¼ckgÃ¤ngig
                puzzle[r][c] = keep;
            }
            return { puzzle, HEq: bestHEq, VEq: bestVEq, HNeq: bestHNeq, VNeq: bestVNeq };
        }

        /* -------- UI -------- */
        function renderBoard(grid, HEq, VEq, HNeq, VNeq) {
            tgBoard.innerHTML = ''; tgCells = []; tgHEq = HEq; tgVEq = VEq; tgHNeq = HNeq; tgVNeq = VNeq;
            for (let r = 0; r < TG; r++) {
                for (let c = 0; c < TG; c++) {
                    const d = document.createElement('div'); d.className = 'cell'; d.dataset.r = r; d.dataset.c = c;
                    const v = grid[r][c]; d.textContent = v ? v : '';
                    if (v != null) d.dataset.lock = '1';
                    if (HEq[r][c] === '=') d.classList.add('eq-right');
                    if (VEq[r][c] === '=') d.classList.add('eq-down');
                    if (HNeq[r][c] === 'Ã—') d.classList.add('neq-right');
                    if (VNeq[r][c] === 'Ã—') d.classList.add('neq-down');
                    d.onclick = () => { if (d.dataset.lock === '1') return; const cur = d.textContent; d.textContent = cur === '' ? S : cur === S ? M : '' };
                    tgBoard.appendChild(d);
                    if (!tgCells[r]) tgCells[r] = []; tgCells[r][c] = d;
                }
            }
        }
        function readGrid() {
            const g = empty();
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                const t = tgCells[r][c].textContent; g[r][c] = t === '' ? null : (t === S ? S : M);
            }
            return g;
        }
        function say(msg, good) { tgMsg.classList.remove('hidden'); tgMsg.innerHTML = `<span class="${good ? 'ok' : 'bad'}">${msg}</span>` }

        /* Check */
        function tgCheck() {
            const g = readGrid();
            if (!countsOK(g)) return say('Max 3 von S/M pro Zeile/Spalte nicht Ã¼berschreiten.', false);
            if (noTriples(g)) return say('Verbotene Dreierfolge gefunden.', false);
            // Soft-Warnungen gegen die Overlay-Hinweise
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                if (tgHEq[r][c] === '=' && g[r][c] != null && c + 1 < TG && g[r][c + 1] != null && g[r][c] !== g[r][c + 1]) return say('Hinweis "=" verletzt.', false);
                if (tgVEq[r][c] === '=' && g[r][c] != null && r + 1 < TG && g[r + 1][c] != null && g[r][c] !== g[r + 1][c]) return say('Hinweis "=" verletzt.', false);
                if (tgHNeq[r][c] === 'Ã—' && g[r][c] != null && c + 1 < TG && g[r][c + 1] != null && g[r][c] === g[r][c + 1]) return say('Hinweis "Ã—" verletzt.', false);
                if (tgVNeq[r][c] === 'Ã—' && g[r][c] != null && r + 1 < TG && g[r + 1][c] != null && g[r][c] === g[r + 1][c]) return say('Hinweis "Ã—" verletzt.', false);
            }
            if (isFull(g)) {
                if (!countsExact(g)) return say('GefÃ¼llt, aber es mÃ¼ssen genau 3 S und 3 M pro Zeile/Spalte sein.', false);
                if (!rowsUnique(g) || !colsUnique(g)) return say('GefÃ¼llt, aber doppelte Zeilen/Spalten.', false);
                return say(eq(g, tgSolution) ? 'GelÃ¶st! âœ…' : 'Regelkonformes Alternativ-Grid (nicht die Ziel-LÃ¶sung).', eq(g, tgSolution));
            }
            return say('Bisher konsistent. Weiter!', true);
        }

        /* Hint: eine logische Ableitung anwenden */
        function tgHint() {
            const cur = readGrid();
            const step = solveByLogic(cur);
            if (eq(step.grid, cur)) { say('Kein 1-Schritt-Hinweis gefunden.', false); return }
            // erste Differenz anwenden
            for (let r = 0; r < TG; r++) for (let c = 0; c < TG; c++) {
                if (cur[r][c] !== step.grid[r][c] && step.grid[r][c] != null) {
                    tgCells[r][c].textContent = step.grid[r][c];
                    tgCells[r][c].classList.add('flash'); setTimeout(() => tgCells[r][c].classList.remove('flash'), 180);
                    if (step.HNeq[r][c - 1] === 'Ã—') tgCells[r][c - 1]?.classList.add('neq-right');
                    if (step.VNeq[r - 1]?.[c] === 'Ã—') tgCells[r - 1]?.[c]?.classList.add('neq-down');
                    if (step.HEq[r][c - 1] === '=') tgCells[r][c - 1]?.classList.add('eq-right');
                    if (step.VEq[r - 1]?.[c] === '=') tgCells[r - 1]?.[c]?.classList.add('eq-down');
                    say('Logischen Schritt angewandt.', true);
                    return;
                }
            }
        }

        /* New: generiere LÃ¶sung -> carve mit Logik+Eindeutigkeit -> render */
        function tgNew() {
            tgMsg.classList.add('hidden');
            tgSolution = genSolved();
            const carved = carveFromSolution(tgSolution);
            tgGivens = carved.puzzle;
            renderBoard(tgGivens, carved.HEq, carved.VEq, carved.HNeq, carved.VNeq);
        }

        /* wire buttons */
        document.getElementById('tgNew').onclick = tgNew;
        document.getElementById('tgCheck').onclick = tgCheck;
        document.getElementById('tgHint').onclick = tgHint;

        /* boot */
        tgNew();
        /* ------------------- /TANGO ------------------- */


    </script>
</body>

</html>